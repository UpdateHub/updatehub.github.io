{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"UpdateHub documentation \u00b6 This document intends to assist you to understand how the UpdateHub works. Some of the aspects covered in this documentation are: We present our tool, as well as the supported platforms, information about the available features, and more in What is UpdateHub . Are you curious about UpdateHub features? Quick starting with Raspberry Pi 3 it is a quick step-by-step that shows how easy it is to work with it. In Using UpdateHub Cloud we will talk about the characteristics of UpdateHub Cloud service. This is an especially important section for understanding how the tool works and what it provides. The section Handling UpdateHub agent explains the device internal agent, how it works, and how to change the tasks flows. We describe the workflows that should be used to add UpdateHub support on a new, or existing, a platform using Yocto Project at Integrating with Yocto Project . Please take a look at our FAQ as maybe it has the answer for the questions you may have or send us your question directly via Gitter . Our support team is always happy to support you in case you did not find the information you are after, or if you have critics or suggestions for the UpdateHub . Please get in touch with us at contact@updatehub.io. Syntax used on this documentation \u00b6 We adopted the following syntax across the whole documentation. On text, we use different formats as: bold - implies technologies and enterprises name. italic - is used on variables, artifacts, dashboard options, system path and configurations, layers, and file names. Code - this format is used on code samples throughout the documentation. Besides these formats, we also use boxes to provide tips, warnings, and important aspects to consider. For example: Information Infobox provides additional information on what was recently covered. Tip A tip is an advice on ways to make an operation easier. Important Here is information that can directly influence the user and their interactions with our product, for example, the need to upgrade the account to support more than 5 devices. Attention In this type of box, we find alerts about system configurations and behaviors, such as having to check the SD card before recording an image, for example.","title":"Introduction"},{"location":"#updatehub-documentation","text":"This document intends to assist you to understand how the UpdateHub works. Some of the aspects covered in this documentation are: We present our tool, as well as the supported platforms, information about the available features, and more in What is UpdateHub . Are you curious about UpdateHub features? Quick starting with Raspberry Pi 3 it is a quick step-by-step that shows how easy it is to work with it. In Using UpdateHub Cloud we will talk about the characteristics of UpdateHub Cloud service. This is an especially important section for understanding how the tool works and what it provides. The section Handling UpdateHub agent explains the device internal agent, how it works, and how to change the tasks flows. We describe the workflows that should be used to add UpdateHub support on a new, or existing, a platform using Yocto Project at Integrating with Yocto Project . Please take a look at our FAQ as maybe it has the answer for the questions you may have or send us your question directly via Gitter . Our support team is always happy to support you in case you did not find the information you are after, or if you have critics or suggestions for the UpdateHub . Please get in touch with us at contact@updatehub.io.","title":"UpdateHub documentation"},{"location":"#syntax-used-on-this-documentation","text":"We adopted the following syntax across the whole documentation. On text, we use different formats as: bold - implies technologies and enterprises name. italic - is used on variables, artifacts, dashboard options, system path and configurations, layers, and file names. Code - this format is used on code samples throughout the documentation. Besides these formats, we also use boxes to provide tips, warnings, and important aspects to consider. For example: Information Infobox provides additional information on what was recently covered. Tip A tip is an advice on ways to make an operation easier. Important Here is information that can directly influence the user and their interactions with our product, for example, the need to upgrade the account to support more than 5 devices. Attention In this type of box, we find alerts about system configurations and behaviors, such as having to check the SD card before recording an image, for example.","title":"Syntax used on this documentation"},{"location":"quick-starting-with-raspberrypi3/","text":"Quick starting with RaspberryPi 3 \u00b6 In this step-by-step, we show how easily you can generate a Linux image, that has UpdateHub support, using Yocto Project in a Raspberry Pi 3 development board. So you can get to know UpdateHub in a practical way and see how simple it is to keep your devices updated in the field using a secure way of communication. We assume that you have previous experience with the Yocto Project , know the main terms and have already created an image using it. If you are new to this tutorial , you can use it. What You Will Need \u00b6 To follow this guide, you will need the following: A Raspberry Pi 3 Model B or B+ An 4 GB or larger micro SD card An Ethernet cable for wired connectivity to the internet An UpdateHub account to access the hosted server An UpdateHub account allows manager even 5 devices; for more support and features is advisable migrate your plan . Step guide \u00b6 To generate an image that connects a device to the UpdateHub Cloud , we will first have to prepare the Yocto Project environment with the basic layers to generate an image with support for UpdateHub . In addition to the layers, you will need to configure some variables that are generated on the Dashboard. The first is the product identifier to which the device and the image will be connected. Then we will have to generate an access key in Settings that will authenticate the device when it accesses the server. At this point, we check the local.conf file to verify that everything is correct and build the image . That's it! Now just burn the image on the device and it is prepared with OTA support. Additionally we update the image by adding ssh support and we send the updated image to UpdateHub Cloud and show how simple an update of your device is with the create a rollout . First step: preparing the Yocto Project environment \u00b6 The first step is to initialize the environment to build a Linux image using Yocto Project and for that, we need to fetch all the needed layers, that includes the main OE-Core layers, the BSP layer that adds support to Raspberry Pi and the layers that add support to UpdateHub . To get the platform you need to have Repo (a tool for manager git repositories) installed: For Debian/Ubuntu based distros run: sudo apt-get install repo For others distros, check the distro documentation or install repo manually: mkdir -p ~/.bin PATH=\"${HOME}/.bin:${PATH}\" curl https://storage.googleapis.com/git-repo-downloads/repo > ~/.bin/repo chmod a+rx ~/.bin/repo To download the platform source, that will download all layers: mkdir updatehub-get-started cd updatehub-get-started repo init -u https://github.com/UpdateHub/updatehub-yocto-project-get-started.git -b dunfell repo sync Setup the environment with: source ./setup-environment build At the end of the commands, you have all metadata you need to start to work. Second step: creating a product \u00b6 One of the variables needed to generate the image is the product identifier that is generated when creating a Product . To create a Product just go to Dashboard and click on Add product . By doing that the following dialog will be displayed. You should choose a Product name and in Owner choose Me . About the name and owner Bear in the mind that after you create a Product you can not rename or delete it, and you can not transfer it to an organization or vice versa, so have sure you are choosing the correct name and the owner. After the Product has been created a Unique Identifier Number ( UPDATEHUB_PRODUCT_UID ) is generated to identify it. This number should be added to your build to allow the UpdateHub Agent , which runs inside the target device, to communicate with the UpdateHub Cloud . For convenience, you can add the UPDATEHUB_PRODUCT_UID to your build/conf/local.conf configuration file when prototyping. However, as this is information that will be permanent for the whole product life cycle, it should be put inside your distribution configuration file or image recipe. In case you didn't copy the Product Unique Identifier Number the moment that you create it on the UpdateHub Cloud doesn't worry. To get access to this information again you must click on the Product icon and the Unique Identifier Number will be shown to you. Once you have logged in, the Products page will display the list of your own products and the other products you have access to. Third step: generating an Access Key \u00b6 To authenticate and authorize requests for a project build with the UpdateHub Cloud you must have a security credential in the form of an application access key. Each access key is specific to your user and is used to upload the packages update or any other external integration which needs to access the UpdateHub API. To generate an Access Key you must enter the Settings menu and click on the + Request Access Key button. Choose a name for the key and select the API Key owner as Me . Once the Access Key is created a dialog will appear to show the security credentials. Save your keys On the moment that this window is closed the keys will not be shown again and if you lose them you must revoke the Access Key and generate a new one. Include these variables in build/conf/local.conf : UPDATEHUB_ACCESS_ID = \"your-email@gmail.com-8bc21121049af...\" UPDATEHUB_ACCESS_SECRET = \"9b1fcee96795fa5dea5cd04cb1d2...\" Fourth step: Configuring the local.conf file \u00b6 Come back to Yocto Project directory on your computer. After fetching the bitbake layers are important to change some variables in the local.conf file. Here we'll put the variables that were generated before: UPDATEHUB_PRODUCT_UID from the Product and the UPDATEHUB_ACCESS_ID and UPDATEHUB_ACCESS_SECRET generated in Settings . UPDATEHUB_PRODUCT_UID = \"05344b71c3e9f8...\" UPDATEHUB_ACCESS_ID = \"your-email@gmail.com-8bc21121049af...\" UPDATEHUB_ACCESS_SECRET = \"9b1fcee96795fa5dea5cd04cb1d2...\" UPDATEHUB_PACKAGE_VERSION_SUFFIX is used to add a suffix in the version of the image being generated. This is useful for placing a version number and incrementing with each new image. UPDATEHUB_PACKAGE_VERSION_SUFFIX =\"-test-image-1.0\" Finally, the final of your local.conf file should seem like this. UPDATEHUB_PRODUCT_UID = \"05344b71c3e9f8...\" UPDATEHUB_ACCESS_ID = \"your-email@gmail.com-8bc21121049af...\" UPDATEHUB_ACCESS_SECRET = \"9b1fcee96795fa5dea5cd04cb1d2...\" UPDATEHUB_PACKAGE_VERSION_SUFFIX = \"-test-image-1.0\" Fifth step: building an image \u00b6 With all variables configured, now we can generate our image. Open a terminal, go to your build directory and type: bitbake updatehub-image-base The generate image process can take a good time; it is dependent directly of the host resources. Now it's time to burn the image in the SD card. Then in a terminal go to this directory: build/tmp/deploy/images/raspberrypi3/ And type this: Check the name of the SD card before executing the command below! You can check the device name that corresponds to the SD card using the command dmesg . zcat updatehub-image-base-raspberrypi3.wic.gz | sudo dd of=/dev/sdX With the SD card ready, you can insert it into the target and connect it to RaspberryPi . The image is configured to obtain an IP address using DHCP. To access the console, the user is set to \"root\u201d and doesn't need to enter a password, just hit Enter . You can confirm the version of the image that is running on the target with the command: cat /etc/os-release You will see the version that you put in the local.conf file. O.S. Systems Embedded Linux 19.10 raspberrypi3 ttyS0 root@raspberrypi3:~# cat /etc/os-release ID=\"oel\" NAME=\"O.S. Systems Embedded Linux\" VERSION=\"19.10\" VERSION_ID=\"19.10-test-image-1.0\" PRETTY_NAME=\"O.S. Systems Embedded Linux 19.10\" UPDATEHUB_PRODUCT_UID=\"05344b71c3e9f8...\"\" root@raspberrypi3:~# Sixth step: changing the image \u00b6 Now that the whole upgrade process has been explained, we'll add support for an SSH server on the target and create an update package to install this functionality. To add support for the SSH OpenSSH server add the following line to the conf/local.conf file: IMAGE_FEATURES += \"ssh-server-openssh\" And change the variable UPDATEHUB_PACKAGE_VERSION_SUFFIX to use the version of our test image: UPDATEHUB_PACKAGE_VERSION_SUFFIX = \"-test-image-2.0\" Seventh step: sending a new image version \u00b6 We can save the file, generate a new update package, and send the new file to UpdateHub Cloud by running the same command: bitbake updatehub-image-base -c uhupush After sending, the package will be available on the Dashboard in the Package section of the corresponding Product page. Eighth step: creating a rollout \u00b6 The rollout is the process of sending an updated image to devices in the field through UpdateHub Cloud . To create a rollout we have to access the Dashboard , access the Product card we created before and then click on Create rollout . In the displayed window choose the available version and click on Save and start . The status of the update process is shown in the displayed window, and can also be followed by the Devices section for each device individually. When the status shows updated, we can access the target using the SSH protocol, for this type in the host: ssh root@TARGET_IP_ADDR No password is required, just hit Enter and we will be in the target console. Again we can check the version with the contents of the /etc/os-release file. Here we finish our quick start, but we invite you to learn more about UpdateHub in the rest of the documentation. If you have encountered difficulties or have any questions or suggestions, please contact us through the Gitter or send us an email by contact@updatehub.io.","title":"Quick starting with Raspberry Pi 3"},{"location":"quick-starting-with-raspberrypi3/#quick-starting-with-raspberrypi-3","text":"In this step-by-step, we show how easily you can generate a Linux image, that has UpdateHub support, using Yocto Project in a Raspberry Pi 3 development board. So you can get to know UpdateHub in a practical way and see how simple it is to keep your devices updated in the field using a secure way of communication. We assume that you have previous experience with the Yocto Project , know the main terms and have already created an image using it. If you are new to this tutorial , you can use it.","title":"Quick starting with RaspberryPi 3"},{"location":"quick-starting-with-raspberrypi3/#what-you-will-need","text":"To follow this guide, you will need the following: A Raspberry Pi 3 Model B or B+ An 4 GB or larger micro SD card An Ethernet cable for wired connectivity to the internet An UpdateHub account to access the hosted server An UpdateHub account allows manager even 5 devices; for more support and features is advisable migrate your plan .","title":"What You Will Need"},{"location":"quick-starting-with-raspberrypi3/#step-guide","text":"To generate an image that connects a device to the UpdateHub Cloud , we will first have to prepare the Yocto Project environment with the basic layers to generate an image with support for UpdateHub . In addition to the layers, you will need to configure some variables that are generated on the Dashboard. The first is the product identifier to which the device and the image will be connected. Then we will have to generate an access key in Settings that will authenticate the device when it accesses the server. At this point, we check the local.conf file to verify that everything is correct and build the image . That's it! Now just burn the image on the device and it is prepared with OTA support. Additionally we update the image by adding ssh support and we send the updated image to UpdateHub Cloud and show how simple an update of your device is with the create a rollout .","title":"Step guide"},{"location":"quick-starting-with-raspberrypi3/#first-step-preparing-the-yocto-project-environment","text":"The first step is to initialize the environment to build a Linux image using Yocto Project and for that, we need to fetch all the needed layers, that includes the main OE-Core layers, the BSP layer that adds support to Raspberry Pi and the layers that add support to UpdateHub . To get the platform you need to have Repo (a tool for manager git repositories) installed: For Debian/Ubuntu based distros run: sudo apt-get install repo For others distros, check the distro documentation or install repo manually: mkdir -p ~/.bin PATH=\"${HOME}/.bin:${PATH}\" curl https://storage.googleapis.com/git-repo-downloads/repo > ~/.bin/repo chmod a+rx ~/.bin/repo To download the platform source, that will download all layers: mkdir updatehub-get-started cd updatehub-get-started repo init -u https://github.com/UpdateHub/updatehub-yocto-project-get-started.git -b dunfell repo sync Setup the environment with: source ./setup-environment build At the end of the commands, you have all metadata you need to start to work.","title":"First step: preparing the Yocto Project environment"},{"location":"quick-starting-with-raspberrypi3/#second-step-creating-a-product","text":"One of the variables needed to generate the image is the product identifier that is generated when creating a Product . To create a Product just go to Dashboard and click on Add product . By doing that the following dialog will be displayed. You should choose a Product name and in Owner choose Me . About the name and owner Bear in the mind that after you create a Product you can not rename or delete it, and you can not transfer it to an organization or vice versa, so have sure you are choosing the correct name and the owner. After the Product has been created a Unique Identifier Number ( UPDATEHUB_PRODUCT_UID ) is generated to identify it. This number should be added to your build to allow the UpdateHub Agent , which runs inside the target device, to communicate with the UpdateHub Cloud . For convenience, you can add the UPDATEHUB_PRODUCT_UID to your build/conf/local.conf configuration file when prototyping. However, as this is information that will be permanent for the whole product life cycle, it should be put inside your distribution configuration file or image recipe. In case you didn't copy the Product Unique Identifier Number the moment that you create it on the UpdateHub Cloud doesn't worry. To get access to this information again you must click on the Product icon and the Unique Identifier Number will be shown to you. Once you have logged in, the Products page will display the list of your own products and the other products you have access to.","title":"Second step: creating a product"},{"location":"quick-starting-with-raspberrypi3/#third-step-generating-an-access-key","text":"To authenticate and authorize requests for a project build with the UpdateHub Cloud you must have a security credential in the form of an application access key. Each access key is specific to your user and is used to upload the packages update or any other external integration which needs to access the UpdateHub API. To generate an Access Key you must enter the Settings menu and click on the + Request Access Key button. Choose a name for the key and select the API Key owner as Me . Once the Access Key is created a dialog will appear to show the security credentials. Save your keys On the moment that this window is closed the keys will not be shown again and if you lose them you must revoke the Access Key and generate a new one. Include these variables in build/conf/local.conf : UPDATEHUB_ACCESS_ID = \"your-email@gmail.com-8bc21121049af...\" UPDATEHUB_ACCESS_SECRET = \"9b1fcee96795fa5dea5cd04cb1d2...\"","title":"Third step: generating an Access Key"},{"location":"quick-starting-with-raspberrypi3/#fourth-step-configuring-the-localconf-file","text":"Come back to Yocto Project directory on your computer. After fetching the bitbake layers are important to change some variables in the local.conf file. Here we'll put the variables that were generated before: UPDATEHUB_PRODUCT_UID from the Product and the UPDATEHUB_ACCESS_ID and UPDATEHUB_ACCESS_SECRET generated in Settings . UPDATEHUB_PRODUCT_UID = \"05344b71c3e9f8...\" UPDATEHUB_ACCESS_ID = \"your-email@gmail.com-8bc21121049af...\" UPDATEHUB_ACCESS_SECRET = \"9b1fcee96795fa5dea5cd04cb1d2...\" UPDATEHUB_PACKAGE_VERSION_SUFFIX is used to add a suffix in the version of the image being generated. This is useful for placing a version number and incrementing with each new image. UPDATEHUB_PACKAGE_VERSION_SUFFIX =\"-test-image-1.0\" Finally, the final of your local.conf file should seem like this. UPDATEHUB_PRODUCT_UID = \"05344b71c3e9f8...\" UPDATEHUB_ACCESS_ID = \"your-email@gmail.com-8bc21121049af...\" UPDATEHUB_ACCESS_SECRET = \"9b1fcee96795fa5dea5cd04cb1d2...\" UPDATEHUB_PACKAGE_VERSION_SUFFIX = \"-test-image-1.0\"","title":"Fourth step: Configuring the local.conf file"},{"location":"quick-starting-with-raspberrypi3/#fifth-step-building-an-image","text":"With all variables configured, now we can generate our image. Open a terminal, go to your build directory and type: bitbake updatehub-image-base The generate image process can take a good time; it is dependent directly of the host resources. Now it's time to burn the image in the SD card. Then in a terminal go to this directory: build/tmp/deploy/images/raspberrypi3/ And type this: Check the name of the SD card before executing the command below! You can check the device name that corresponds to the SD card using the command dmesg . zcat updatehub-image-base-raspberrypi3.wic.gz | sudo dd of=/dev/sdX With the SD card ready, you can insert it into the target and connect it to RaspberryPi . The image is configured to obtain an IP address using DHCP. To access the console, the user is set to \"root\u201d and doesn't need to enter a password, just hit Enter . You can confirm the version of the image that is running on the target with the command: cat /etc/os-release You will see the version that you put in the local.conf file. O.S. Systems Embedded Linux 19.10 raspberrypi3 ttyS0 root@raspberrypi3:~# cat /etc/os-release ID=\"oel\" NAME=\"O.S. Systems Embedded Linux\" VERSION=\"19.10\" VERSION_ID=\"19.10-test-image-1.0\" PRETTY_NAME=\"O.S. Systems Embedded Linux 19.10\" UPDATEHUB_PRODUCT_UID=\"05344b71c3e9f8...\"\" root@raspberrypi3:~#","title":"Fifth step: building an image"},{"location":"quick-starting-with-raspberrypi3/#sixth-step-changing-the-image","text":"Now that the whole upgrade process has been explained, we'll add support for an SSH server on the target and create an update package to install this functionality. To add support for the SSH OpenSSH server add the following line to the conf/local.conf file: IMAGE_FEATURES += \"ssh-server-openssh\" And change the variable UPDATEHUB_PACKAGE_VERSION_SUFFIX to use the version of our test image: UPDATEHUB_PACKAGE_VERSION_SUFFIX = \"-test-image-2.0\"","title":"Sixth step: changing the image"},{"location":"quick-starting-with-raspberrypi3/#seventh-step-sending-a-new-image-version","text":"We can save the file, generate a new update package, and send the new file to UpdateHub Cloud by running the same command: bitbake updatehub-image-base -c uhupush After sending, the package will be available on the Dashboard in the Package section of the corresponding Product page.","title":"Seventh step: sending a new image version"},{"location":"quick-starting-with-raspberrypi3/#eighth-step-creating-a-rollout","text":"The rollout is the process of sending an updated image to devices in the field through UpdateHub Cloud . To create a rollout we have to access the Dashboard , access the Product card we created before and then click on Create rollout . In the displayed window choose the available version and click on Save and start . The status of the update process is shown in the displayed window, and can also be followed by the Devices section for each device individually. When the status shows updated, we can access the target using the SSH protocol, for this type in the host: ssh root@TARGET_IP_ADDR No password is required, just hit Enter and we will be in the target console. Again we can check the version with the contents of the /etc/os-release file. Here we finish our quick start, but we invite you to learn more about UpdateHub in the rest of the documentation. If you have encountered difficulties or have any questions or suggestions, please contact us through the Gitter or send us an email by contact@updatehub.io.","title":"Eighth step: creating a rollout"},{"location":"what-is-updatehub/","text":"What is UpdateHub? \u00b6 UpdateHub is an enterprise-grade solution that makes it simple to remotely update all your embedded devices in the field. It handles all aspects related to sending Firmware Over-the-Air (FOTA) updates with maximum security and efficiency, making your project the center of your attention. Supported Platforms \u00b6 To maximize the diversity of projects which can benefit from UpdateHub use, we provide support for Yocto Project\u2122 and Zephyr Project\u2122 based devices, encompassing Linux and RTOS based devices. Basic Concepts \u00b6 There are a few basic concepts that are important to understand the UpdateHub . Those basic concepts are detailed below: Product: is the base that connects everything together through the UpdateHub . Essentially the Product includes one or multiple Devices , and for each of them, there is a Package version that may be updated using a Rollout . Device: it represents your physical device. It has multiple characteristics that are tracked on the management platform, as such: hardware type, unique identifier, runtime attributes, and more. Package: encompasses a software version, including the filesystem image, bootloader, or any other objects. Rollout: it is essentially a deployment plan. It can be simple as \"send version 2.0 for all devices\" or a more complex plan, selecting specific filters and enforcing a gradual deployment across the devices in the field. Rollback: this allows to roll back to the previous working version if a new version has critical errors, ensuring that the device will continue to function after the upgrade. Features \u00b6 The UpdateHub has a rich feature set. On the management platform side it offers support for: Single and team managed products 2-click rollout creation for fast deployment across all your devices Multi-step rollout support for finner control about the rollout process across your devices (e.g: lab, alpha testers, production) HTTP API to control the system remotely The support provided by the UpdateHub for the device includes: Support for multiple Yocto Project\u2122 and Zephyr Project\u2122 versions Bootloader upgrade support (U-Boot and GRUB) Flash support (NAND, NOR) UBIFS support Update package signature validation for security Automated rollback in case of update fail Conditional installation (content, version, and custom pattern support) Callback support for every update step HTTP API to control and inquiry the local agent UpdateHub Server Editions \u00b6 UpdateHub Server is available in two editions: UpdateHub Community Edition : is ideal for individual developers and small teams looking to get started with UpdateHub and experimenting with Firmware Over-the-Air (FOTA) updates. UpdateHub Cloud : is designed for enterprise development and IT teams who need an end-to-end solution to build and ship Firmware Over-the-Air (FOTA) updates with maximum security and efficiency at any scale. UpdateHub Cloud \u00b6 UpdateHub Cloud have a rich but simple interface with all the tools required to: Create and operate your own Products Access Products from organizations Check when new Packages are available for updates Oversee a fleet of Devices on the field Deploy updates via an Over-The-Air system running the Rollouts In essence the UpdateHub Cloud allows oversight over the whole UpdateHub platform and operations, making it easy to manage any need that you might have. Comparasion Table \u00b6 See the comparison table below to help you to choose which version fits your need: Feature UpdateHub CE UpdateHub Cloud Secure communication (HTTPS, CoAP over DTLS) \u2718 \u2714 Signed packages \u2714 \u2714 Rollouts \u2714 \u2714 Large scale rollouts \u2718 \u2714 Multiple organizations \u2718 \u2714 Fully monitored updates \u2714 \u2714 Teams \u2718 \u2714 HTTP API \u2718 \u2714 Package upload \u2714 \u2714 Multiple products \u2718 \u2714 Advanced device filter \u2718 \u2714 Multiple users \u2718 \u2714","title":"What is UpdateHub"},{"location":"what-is-updatehub/#what-is-updatehub","text":"UpdateHub is an enterprise-grade solution that makes it simple to remotely update all your embedded devices in the field. It handles all aspects related to sending Firmware Over-the-Air (FOTA) updates with maximum security and efficiency, making your project the center of your attention.","title":"What is UpdateHub?"},{"location":"what-is-updatehub/#supported-platforms","text":"To maximize the diversity of projects which can benefit from UpdateHub use, we provide support for Yocto Project\u2122 and Zephyr Project\u2122 based devices, encompassing Linux and RTOS based devices.","title":"Supported Platforms"},{"location":"what-is-updatehub/#basic-concepts","text":"There are a few basic concepts that are important to understand the UpdateHub . Those basic concepts are detailed below: Product: is the base that connects everything together through the UpdateHub . Essentially the Product includes one or multiple Devices , and for each of them, there is a Package version that may be updated using a Rollout . Device: it represents your physical device. It has multiple characteristics that are tracked on the management platform, as such: hardware type, unique identifier, runtime attributes, and more. Package: encompasses a software version, including the filesystem image, bootloader, or any other objects. Rollout: it is essentially a deployment plan. It can be simple as \"send version 2.0 for all devices\" or a more complex plan, selecting specific filters and enforcing a gradual deployment across the devices in the field. Rollback: this allows to roll back to the previous working version if a new version has critical errors, ensuring that the device will continue to function after the upgrade.","title":"Basic Concepts"},{"location":"what-is-updatehub/#features","text":"The UpdateHub has a rich feature set. On the management platform side it offers support for: Single and team managed products 2-click rollout creation for fast deployment across all your devices Multi-step rollout support for finner control about the rollout process across your devices (e.g: lab, alpha testers, production) HTTP API to control the system remotely The support provided by the UpdateHub for the device includes: Support for multiple Yocto Project\u2122 and Zephyr Project\u2122 versions Bootloader upgrade support (U-Boot and GRUB) Flash support (NAND, NOR) UBIFS support Update package signature validation for security Automated rollback in case of update fail Conditional installation (content, version, and custom pattern support) Callback support for every update step HTTP API to control and inquiry the local agent","title":"Features"},{"location":"what-is-updatehub/#updatehub-server-editions","text":"UpdateHub Server is available in two editions: UpdateHub Community Edition : is ideal for individual developers and small teams looking to get started with UpdateHub and experimenting with Firmware Over-the-Air (FOTA) updates. UpdateHub Cloud : is designed for enterprise development and IT teams who need an end-to-end solution to build and ship Firmware Over-the-Air (FOTA) updates with maximum security and efficiency at any scale.","title":"UpdateHub Server Editions"},{"location":"what-is-updatehub/#updatehub-cloud","text":"UpdateHub Cloud have a rich but simple interface with all the tools required to: Create and operate your own Products Access Products from organizations Check when new Packages are available for updates Oversee a fleet of Devices on the field Deploy updates via an Over-The-Air system running the Rollouts In essence the UpdateHub Cloud allows oversight over the whole UpdateHub platform and operations, making it easy to manage any need that you might have.","title":"UpdateHub Cloud"},{"location":"what-is-updatehub/#comparasion-table","text":"See the comparison table below to help you to choose which version fits your need: Feature UpdateHub CE UpdateHub Cloud Secure communication (HTTPS, CoAP over DTLS) \u2718 \u2714 Signed packages \u2714 \u2714 Rollouts \u2714 \u2714 Large scale rollouts \u2718 \u2714 Multiple organizations \u2718 \u2714 Fully monitored updates \u2714 \u2714 Teams \u2718 \u2714 HTTP API \u2718 \u2714 Package upload \u2714 \u2714 Multiple products \u2718 \u2714 Advanced device filter \u2718 \u2714 Multiple users \u2718 \u2714","title":"Comparasion Table"},{"location":"faq/faq-questions/","text":"General \u00b6 What is UpdateHub ? \u00b6 UpdateHub is a tool that turns all of the firmware process easy and secure. It runs all tasks involved in the updating execution and allows the user to set the behavior of activity flow. The UpdateHub also allows the user to check and manage his device\u2019s fleet in a unique location. Which versions are available? \u00b6 UpdateHub has two flavors: Open Source and Cloud . The tool is made of two parts: an agent (internal in devices) and a server. The UpdateHub Agent is the same in both versions, but the server on the Open Source version is hosted by the user, while UpdateHub Cloud is hosted in a dedicated, secure cloud server. The use of UpdateHub is free? \u00b6 The Open Source version is totally free forever. The Cloud version allows registering up to 5 free devices. How do I use it? \u00b6 The installing and use processes are described in detail in our tutorial Quick starting with Raspberry Pi 3 . Which operational systems supported it? \u00b6 The UpdateHub works with Yocto Project Embedded Linux and Zephyr Project -based devices. The UpdateHub can update the applications in the device? \u00b6 No. The UpdateHub deals with the updates in an atomic way, to reduce the risk of errors and simplify the Quality Assurance process which every update package usually goes through during the product development cycle. Dashboard \u00b6 Why does the Rollout process appear unfinished? \u00b6 It happens because the process continues allowing new Devices to the existing Rollout . It's also important to cover the cases where manufacturing happens without network connectivity and the adding Devices occurs later. That is the reason why UpdateHub works on, how we call, an infinite Rollout . The UpdateHub uses which connections type to update the device? \u00b6 The UpdateHub Agent in Linux uses HTTPS to connect to Cloud , or in the case of Zephyr , the connection is made through CoAP (Constrained Application Protocol). How to access my Product UID? \u00b6 The Product UID is your Product \u2019s unique identifier and is essential to UpdateHub works. It\u2019s shown when the Product was created, but also can be consulted in Dashboard , in the Product page clicking on the icon of Product . How do I know my RSA key ? \u00b6 The RSA key is available just in creation, so if you lost this, you must create a new key (and save the key in a secure local). A Rollout configured to cover all Devices will cover even the Devices connected to the platform after the Rollout created? \u00b6 Yes. That\u2019s why UpdateHub never finishes a Rollout and even if new Devices are connected it can \u201cjoin\u201d the live Rollout if the filter matches. Why does my Rollout does not reach 100%? \u00b6 It happens when Devices are not updated because of external factors as network failure, or when its next probe time has not been reached yet. What\u2019s the Fault Tolerance in the Rollout settings? \u00b6 This rate allows the Rollout process to fail on some Devices , and if the rate is exceeded the Rollout process is interrupted, keeping the devices that have successfully completed updated, but not continuing for those the Devices are still pending. Pricing \u00b6 How is UpdateHub charged? \u00b6 UpdateHub billing is metered depending on the resources used during the period. We prepared an Account Explained at the menu Pricing . Check it out! It\u2019s also possible to estimate these costs by the UpdateHub Calculator . Is it possible to get an estimate before starting to use it? \u00b6 Sure. You can estimate your monthly billing using the UpdateHub Calculator or by contacting our team directly by form contact form. How do I estimate the cost using the Calculator ? \u00b6 On Pricing , go to Estimate your costs bottom and select the number of devices that will be activated. In the left menu, firstly you\u2019ll choose how many devices you would like to update. Then, choose the update size and how many update rollouts you will do. Lastly, by selecting the percentage of devices included for each update rollout, you will get the Devices and Rollout billing estimate. The billing is different from that estimated. What happened? \u00b6 The UpdateHub Calculator considers the main fees charged on UpdateHub to generate an estimative. It doesn\u2019t mean that all fees will be covered every time or with the same value. For example, if Devices are already activated, the activation fee won't be charged. As well as the percentage of devices included in a Rollout update may be less than 100%. What Activation fee cover? Is it charged monthly? \u00b6 The activation fee will be charged only when a device is activated. But take care, if you deactivate a device and activate it after billing, so its activation fee will be charged again. But, if you disable one device and activate it in the same month, the fee will be charged just one time. I'm using UpdateHub Cloud on 5 devices, but I need to add a new one. How to upgrade my account? \u00b6 In your Dashboard , access the Billing by clicking on the account icon on the top right, and later click on Unlock unlimited usage . Just fill the field and, your account now is premium.","title":"FAQ"},{"location":"faq/faq-questions/#general","text":"","title":"General"},{"location":"faq/faq-questions/#what-is-updatehub","text":"UpdateHub is a tool that turns all of the firmware process easy and secure. It runs all tasks involved in the updating execution and allows the user to set the behavior of activity flow. The UpdateHub also allows the user to check and manage his device\u2019s fleet in a unique location.","title":"What is UpdateHub?"},{"location":"faq/faq-questions/#which-versions-are-available","text":"UpdateHub has two flavors: Open Source and Cloud . The tool is made of two parts: an agent (internal in devices) and a server. The UpdateHub Agent is the same in both versions, but the server on the Open Source version is hosted by the user, while UpdateHub Cloud is hosted in a dedicated, secure cloud server.","title":"Which versions are available?"},{"location":"faq/faq-questions/#the-use-of-updatehub-is-free","text":"The Open Source version is totally free forever. The Cloud version allows registering up to 5 free devices.","title":"The use of UpdateHub is free?"},{"location":"faq/faq-questions/#how-do-i-use-it","text":"The installing and use processes are described in detail in our tutorial Quick starting with Raspberry Pi 3 .","title":"How do I use it?"},{"location":"faq/faq-questions/#which-operational-systems-supported-it","text":"The UpdateHub works with Yocto Project Embedded Linux and Zephyr Project -based devices.","title":"Which operational systems supported it?"},{"location":"faq/faq-questions/#the-updatehub-can-update-the-applications-in-the-device","text":"No. The UpdateHub deals with the updates in an atomic way, to reduce the risk of errors and simplify the Quality Assurance process which every update package usually goes through during the product development cycle.","title":"The UpdateHub can update the applications in the device?"},{"location":"faq/faq-questions/#dashboard","text":"","title":"Dashboard"},{"location":"faq/faq-questions/#why-does-the-rollout-process-appear-unfinished","text":"It happens because the process continues allowing new Devices to the existing Rollout . It's also important to cover the cases where manufacturing happens without network connectivity and the adding Devices occurs later. That is the reason why UpdateHub works on, how we call, an infinite Rollout .","title":"Why does the Rollout process appear unfinished?"},{"location":"faq/faq-questions/#the-updatehub-uses-which-connections-type-to-update-the-device","text":"The UpdateHub Agent in Linux uses HTTPS to connect to Cloud , or in the case of Zephyr , the connection is made through CoAP (Constrained Application Protocol).","title":"The UpdateHub uses which connections type to update the device?"},{"location":"faq/faq-questions/#how-to-access-my-product-uid","text":"The Product UID is your Product \u2019s unique identifier and is essential to UpdateHub works. It\u2019s shown when the Product was created, but also can be consulted in Dashboard , in the Product page clicking on the icon of Product .","title":"How to access my Product UID?"},{"location":"faq/faq-questions/#how-do-i-know-my-rsa-key","text":"The RSA key is available just in creation, so if you lost this, you must create a new key (and save the key in a secure local).","title":"How do I know my RSA key?"},{"location":"faq/faq-questions/#a-rollout-configured-to-cover-all-devices-will-cover-even-the-devices-connected-to-the-platform-after-the-rollout-created","text":"Yes. That\u2019s why UpdateHub never finishes a Rollout and even if new Devices are connected it can \u201cjoin\u201d the live Rollout if the filter matches.","title":"A Rollout configured to cover all Devices will cover even the Devices connected to the platform after the Rollout created?"},{"location":"faq/faq-questions/#why-does-my-rollout-does-not-reach-100","text":"It happens when Devices are not updated because of external factors as network failure, or when its next probe time has not been reached yet.","title":"Why does my Rollout does not reach 100%?"},{"location":"faq/faq-questions/#whats-the-fault-tolerance-in-the-rollout-settings","text":"This rate allows the Rollout process to fail on some Devices , and if the rate is exceeded the Rollout process is interrupted, keeping the devices that have successfully completed updated, but not continuing for those the Devices are still pending.","title":"What\u2019s the Fault Tolerance in the Rollout settings?"},{"location":"faq/faq-questions/#pricing","text":"","title":"Pricing"},{"location":"faq/faq-questions/#how-is-updatehub-charged","text":"UpdateHub billing is metered depending on the resources used during the period. We prepared an Account Explained at the menu Pricing . Check it out! It\u2019s also possible to estimate these costs by the UpdateHub Calculator .","title":"How is UpdateHub charged?"},{"location":"faq/faq-questions/#is-it-possible-to-get-an-estimate-before-starting-to-use-it","text":"Sure. You can estimate your monthly billing using the UpdateHub Calculator or by contacting our team directly by form contact form.","title":"Is it possible to get an estimate before starting to use it?"},{"location":"faq/faq-questions/#how-do-i-estimate-the-cost-using-the-calculator","text":"On Pricing , go to Estimate your costs bottom and select the number of devices that will be activated. In the left menu, firstly you\u2019ll choose how many devices you would like to update. Then, choose the update size and how many update rollouts you will do. Lastly, by selecting the percentage of devices included for each update rollout, you will get the Devices and Rollout billing estimate.","title":"How do I estimate the cost using the Calculator?"},{"location":"faq/faq-questions/#the-billing-is-different-from-that-estimated-what-happened","text":"The UpdateHub Calculator considers the main fees charged on UpdateHub to generate an estimative. It doesn\u2019t mean that all fees will be covered every time or with the same value. For example, if Devices are already activated, the activation fee won't be charged. As well as the percentage of devices included in a Rollout update may be less than 100%.","title":"The billing is different from that estimated. What happened?"},{"location":"faq/faq-questions/#what-activation-fee-cover-is-it-charged-monthly","text":"The activation fee will be charged only when a device is activated. But take care, if you deactivate a device and activate it after billing, so its activation fee will be charged again. But, if you disable one device and activate it in the same month, the fee will be charged just one time.","title":"What Activation fee cover? Is it charged monthly?"},{"location":"faq/faq-questions/#im-using-updatehub-cloud-on-5-devices-but-i-need-to-add-a-new-one-how-to-upgrade-my-account","text":"In your Dashboard , access the Billing by clicking on the account icon on the top right, and later click on Unlock unlimited usage . Just fill the field and, your account now is premium.","title":"I'm using UpdateHub Cloud on 5 devices, but I need to add a new one. How to upgrade my account?"},{"location":"faq/generating-RSA/","text":"Generating RSA Key \u00b6 The UpdateHub verifies the authenticity of every Package update prior applying it. To do so, it uses a RSA key that to check if the Package has not been modified or corrupted by any means. Each device will contain the public key, public_key.pem , included on the device image, which will validate any received Package before unpacking, which must have been signed with the private key, private_key.pem , when generating the update package. {% hint style='danger' %} Important : Once a device is deployed using a RSA key, the same key is used to validate every update package. It is important to keep the RSA keys safe or you'll not be able to send updates for those devices. {% endhint %} The generation of the RSA keys requires the openssl utility. The private RSA key is generated using the command below: $: mkdir -p ~/updatehub-keys $: openssl genpkey -algorithm RSA -out ~/updatehub-keys/private_key.pem -pkeyopt rsa_keygen_bits:4096 Next we need to extract the public RSA key from the private key. Use the following command: $: openssl rsa -pubout -in ~/updatehub-keys/private_key.pem -out ~/updatehub-keys/public_key.pem","title":"Generating RSA Key"},{"location":"faq/generating-RSA/#generating-rsa-key","text":"The UpdateHub verifies the authenticity of every Package update prior applying it. To do so, it uses a RSA key that to check if the Package has not been modified or corrupted by any means. Each device will contain the public key, public_key.pem , included on the device image, which will validate any received Package before unpacking, which must have been signed with the private key, private_key.pem , when generating the update package. {% hint style='danger' %} Important : Once a device is deployed using a RSA key, the same key is used to validate every update package. It is important to keep the RSA keys safe or you'll not be able to send updates for those devices. {% endhint %} The generation of the RSA keys requires the openssl utility. The private RSA key is generated using the command below: $: mkdir -p ~/updatehub-keys $: openssl genpkey -algorithm RSA -out ~/updatehub-keys/private_key.pem -pkeyopt rsa_keygen_bits:4096 Next we need to extract the public RSA key from the private key. Use the following command: $: openssl rsa -pubout -in ~/updatehub-keys/private_key.pem -out ~/updatehub-keys/public_key.pem","title":"Generating RSA Key"},{"location":"updatehub-agent/controlling-agent/","text":"Changing the UpdateHub Agent is very useful to the user because depending on the environment and goal, the settings must are custom. In this section we show the ways to interact and setting the UpdateHub Agent through the Callbacks use and the SDK functions. Callbacks \u00b6 Callbacks are called during process flows that trigger sets of scripts and allow the user to add behavior to the UpdateHub Agent without changing the agent\u2019s code directly. Callbacks are called upon entering individual states and then execute the assigned scripts. If the user wants, it is possible to change the callback call directly in the code to the most appropriate point of execution of the scripts. There are three types of callback: State change : this callback is called on state changes and informs the current state of the machine. The Probe , Download , Install , Reboot , and Error states use it. Validate : it is called before the state machine starts, and by default, it is called when an update is installed. It allows the execution of tests that guarantee the system\u2019s functionality according to the user's needs. Rollback : is called when the Validate callback fails to validate the new firmware version successfully. In this case, the system must be reverted to the previous version, and actions might need to be taken, such as, for example, reversing the data migration made from the old system to the new one. After that, the agent reboots the device to the old installation. The callbacks are added during the Yocto Project image generating. To this, the script must be available in meta-updatehub/updatehub , together with the recipe (.bb) containing the settings necessary to install and run the script. Below we present the same script examples that quickly implement and allow agent behavior flexibility. Here we have a simple function that checks a specified address to allow it to continue the process. In the Reboot state , the callback makes the agent ask a defined server for permission to proceed and wait for a 200 status code as an answer; anything different will cancel the reboot. Energy and data use management are critical in remote devices, so turning off the unused resources is smart. A script to turn on the GSM connection, for instance, is a good idea and is simple, as shown below: The code checks the current state and, if the state is probe state, it activates the GSM connection, allowing the device checks to available updates on the server to update. Many different use cases are applied in the UpdateHub Agent through the callbacks use. Still, sometimes you want to put this logic inside the application, for instance, to use a graphic screen or use more complex logic that depends on multiple data sources, for example. Those more advanced use cases can be fulfilled using the UpdateHub SDK , in various programming languages, as described in the SDK subsection below. Software Development Kit \u00b6 The UpdateHub has an SDK that allows easy iteration with the UpdatHub Agent . There are four options of SDK: Rust , Python , Qt , and Go . All provide the very same structure and support, being different just the language used. The SDK provides the following API requests: Direct download - allows you to pass to UpdateHub Agent the link to immediate and direct download. Local install - inform the UpdateHub Agent of the address in the local storage that contains the .uhupkg . Probe request - send the control of agent to Probe state . Abort download - cancel the download process. Info - pass the information of the UpdateHub Agent to the user. Log - presents the log register. All of these are detailed in The State Machine and the Flows subsection , where we explain in detail which states can call each request. Whenever you need to interact with the UpdateHub Agent workflow inside your application, the SDK helps in reducing the hassle to do so. We provide an example, in all SDK versions, which shows how to listen to a specific state change. Below we show the code snippet of the listener function in each available language together with the link where the full implementation can be found. In Rust, it is available in updatehub/updatehub-sdk/examples/listener.rs : The Python version is in agent-sdk-python/examples/state_change_listener.py : To see the QT listener, access in agent-sdk-qt/examples/qt/main.cpp : You can check the Go code by visiting agent-sdk-go/examples/listerner/main.go : Keep in your mind that in case of doubt or difficulties you can access our Gitter or send us an email at contact@updatehub.io, we will stay happy to support you.","title":"Controlling the Agent"},{"location":"updatehub-agent/controlling-agent/#callbacks","text":"Callbacks are called during process flows that trigger sets of scripts and allow the user to add behavior to the UpdateHub Agent without changing the agent\u2019s code directly. Callbacks are called upon entering individual states and then execute the assigned scripts. If the user wants, it is possible to change the callback call directly in the code to the most appropriate point of execution of the scripts. There are three types of callback: State change : this callback is called on state changes and informs the current state of the machine. The Probe , Download , Install , Reboot , and Error states use it. Validate : it is called before the state machine starts, and by default, it is called when an update is installed. It allows the execution of tests that guarantee the system\u2019s functionality according to the user's needs. Rollback : is called when the Validate callback fails to validate the new firmware version successfully. In this case, the system must be reverted to the previous version, and actions might need to be taken, such as, for example, reversing the data migration made from the old system to the new one. After that, the agent reboots the device to the old installation. The callbacks are added during the Yocto Project image generating. To this, the script must be available in meta-updatehub/updatehub , together with the recipe (.bb) containing the settings necessary to install and run the script. Below we present the same script examples that quickly implement and allow agent behavior flexibility. Here we have a simple function that checks a specified address to allow it to continue the process. In the Reboot state , the callback makes the agent ask a defined server for permission to proceed and wait for a 200 status code as an answer; anything different will cancel the reboot. Energy and data use management are critical in remote devices, so turning off the unused resources is smart. A script to turn on the GSM connection, for instance, is a good idea and is simple, as shown below: The code checks the current state and, if the state is probe state, it activates the GSM connection, allowing the device checks to available updates on the server to update. Many different use cases are applied in the UpdateHub Agent through the callbacks use. Still, sometimes you want to put this logic inside the application, for instance, to use a graphic screen or use more complex logic that depends on multiple data sources, for example. Those more advanced use cases can be fulfilled using the UpdateHub SDK , in various programming languages, as described in the SDK subsection below.","title":"Callbacks"},{"location":"updatehub-agent/controlling-agent/#software-development-kit","text":"The UpdateHub has an SDK that allows easy iteration with the UpdatHub Agent . There are four options of SDK: Rust , Python , Qt , and Go . All provide the very same structure and support, being different just the language used. The SDK provides the following API requests: Direct download - allows you to pass to UpdateHub Agent the link to immediate and direct download. Local install - inform the UpdateHub Agent of the address in the local storage that contains the .uhupkg . Probe request - send the control of agent to Probe state . Abort download - cancel the download process. Info - pass the information of the UpdateHub Agent to the user. Log - presents the log register. All of these are detailed in The State Machine and the Flows subsection , where we explain in detail which states can call each request. Whenever you need to interact with the UpdateHub Agent workflow inside your application, the SDK helps in reducing the hassle to do so. We provide an example, in all SDK versions, which shows how to listen to a specific state change. Below we show the code snippet of the listener function in each available language together with the link where the full implementation can be found. In Rust, it is available in updatehub/updatehub-sdk/examples/listener.rs : The Python version is in agent-sdk-python/examples/state_change_listener.py : To see the QT listener, access in agent-sdk-qt/examples/qt/main.cpp : You can check the Go code by visiting agent-sdk-go/examples/listerner/main.go : Keep in your mind that in case of doubt or difficulties you can access our Gitter or send us an email at contact@updatehub.io, we will stay happy to support you.","title":"Software Development Kit"},{"location":"updatehub-agent/intro/","text":"The UpdateHub Agent runs on the device and is responsible for managing the whole update process. In addition to that, the Updatehub Agent makes available to the user several settings that allow flexibility in the update processes of your device. To better understand better how the Updatehub Agent works in this section we will cover: The state machine and how it works through possibles of executions flows Description of the task involved in each state How callbacks work","title":"Meeting the UpdateHub Agent"},{"location":"updatehub-agent/state-machine/","text":"This session describes in detail the states in the UpdateHub Agent and the activities ran by them. However, we are tipping you to read the UpdateHub Agent flows before because this clarifies the role of each state in the agent\u2019s execution. The clarify the agente execution, we detail the flows with diagrams. We highlight the states and transitions used in each flow, while states and transitions left in gray are unused for that execution flow. The state machine of the UpdateHub Agent has two state's type. Those are: Preemptive states : they can handle the external requests from the API. Non-preemptive states : when they receive the external request, they respond that the agent is busy and keep the original flow running uninterrupted. The states below are part of the default flow, and external API requests can also trigger some. For more details about the UpdateHub Agent flow, see here. entry point - is the starting point of the state machine. It goes to the Poll state if the automatic probing support is enabled or to the Park state if there is nothing to do. park - the agent stays in this state if the automatic probing support is disabled until it receives external requests. poll - the Poll state moves the state machine to the Probe state , informing if it must process it immediately or wait for the required probe interval to the next probe request. probe - the Probe state checks for an update package in the server, and when there is one available, collects the required metadata to move to the Validation state . In case there is no update available, the machine moves to the Entry Point state . validation - the metadata authenticity and correctness validations must pass so the update packages requirements can be validated before download any update package data. download - all update package objects are downloaded, reusing previously downloaded objects if possible. install - every update package object is installed accordingly to its specific mode of it. The last action is to swap the activated installation set, making the just installed update ready to be used. reboot - restarts the device. error - in case of a mistake, the state machine is moved to the Error state . It registers the log of the process and cleanups and moves the state machine back to the Entry point state . The API can trigger requests to two specific states: Prepare local install state and the Direct download state . Those are described below: direct download - the Direct download state fetches the remote update package (uhupkg) from a custom server and make it available for the Prepare local install state . prepare local install - the uncompression, validation, and correctness checks must pass before moving the state machine to the Install state to proceed with the installation of it. The UpdateHub Agent uses a well-defined state machine, and the description of this machine is the best way to understand the update\u2019s process and how to interact with the agent\u2019s default flow. Here we present the steps performed in the state machine and the summary of executed activities for each of them. An essential aspect of the state machine in use is that every activity is recycled between the states, adding more efficiency. The flow of the Direct Download request and the Local Install request as interesting to explore this as the activities are practically the same. The unique difference is that in the Direct Download request , the agents download the external update\u2019s data, while in the Local Install request , the update\u2019s data is in the local storage. The other activities are the same between the requests. Default behavior \u00b6 The UpdateHub Agent has two operation modes: it can automatically search for new updates on a pre-setted interval. It can also work in an idle mode where searching or installing an update is only triggered by an external interaction. These two different workflows are triggered by the configuration file that the agent reads upon starting. The other workflows are triggered by requests from an external HTTP API that the agent will be listening to, coming from the CLI application, or another program that wants to interact with the UpdateHub Agent . Automatic search \u00b6 The primary usage of the Updatehub Agent is to check for updates in the UpdateHub Cloud server automatically. In this workflow, the agent can work without any interaction from the external API. When the UpdateHub Agent is started, it goes to the Entry point state . This state verifies the settings of the machine for the next transition state. The next stage is the Poll state , where the agent calculates how much time it should wait until checking with the server if there\u2019s an update available. The machine then goes to the Probe state and awaits the appropriate time before checking for new updates on the server. When it is time to access the server to check for an update, the Probe state is activated, and it accesses the UpdateHub Cloud and searches for some new update\u2019s data. If no update is available, the machine goes back to the Entry point state . When an update is available on the server, the Validation state is activated and checks the authenticity of the update\u2019s data. The Validation state also verifies whether the device has the necessary storage space for the update process. Following that, the Download state then downloads all the required data, checking the integrity of the packages, and the Install state installs the data on the proper partition of the device\u2019s storage. By the end of the installation, the device is rebooted. After rebooting, the agent begins at the Entry point state again and restarts a new cycle. In case of an error in Probe , Valitation , Download , Install , or Reboot , the Error state is triggered. The Error state allows the user to use the callback to handle situations. For more information about it, see in the Callback session. No automatic search \u00b6 When the automatic search is disabled, the UpdateHub Agent behaves passively, relying on external requests to inquire for new updates. This mode is useful when the user wants to control the exact time of updates according to his needs and spend fewer device resources, such as energy. When a new request comes, the machine's control changes from the Park state to the requested state and the remainder of the process is the same as the normal state execution. The way to communicate to the Updatehub Agent is through the external HTTP API. The API offers a set of requests for the user to interact with the agent\u2019s flow. We now show the execution flows for these requests. API requests \u00b6 The API has a set of calls that allows the user to interact with the UpdateHub Agent , and here we\u2019ll present them. Regarding the update process, there are the Direct download request and the Local install request . Besides them, the Probe request that when the control is in a preemptive state, give it back to the Probe state . We follow the Abort download request that aborts any download\u2019s process, default, or direct. And lastly, we will show two requests that provide information about the state machine, the Info request and the Log request . Direct download request \u00b6 In this process, the agent receives the Direct download request . The server of search is defined using a link to an alternative server or other location where the uhupkg (update package compatible with the UpdateHub Agent ) is available. Subsequently, the Prepare local install state performs the necessary tasks of space and resources validation, such as storage. With the completion of these activities, the Install state is executed, installing the essential data and deallocating resources that are no longer needed for the process. Finally, the device is restarted with the new image running the Reboot state . Set the URL to the desired location: { \"url\": \"https://some_remote_url.domain/update.uhupkg\" } So, to activate the Direct download request use the command: http://updatehub_agent:port/remote_install Local install request \u00b6 When the UpdateHub Agent receives the Local install request , the update package should already be available on local storage on the device. This can be done with a pen-drive, for example, and requires direct user interference on the device. So, the Prepare local install state verifies the authentication, data integrity and the space available on the device\u2019s storage. It reserves the necessary resources for installation and calls the Install state to proceed with the installation. The device is then rebooted into the newly installed image. The path of the uhupkg file is required, as shown below: { \"file\": \"/tmp/updatehub-image-qa-uh-qemu-x86-64.uhupkg\" } Later, just type: http://updatehub_agent:port/local_install Probe request \u00b6 The Probe request can be accepted during any preemptive state and it returns the control to the Probe state . The purpose of interrupt the flow and sending the state machine control from preemptive state to Probe state is that it is possible to start the update process, without waiting for the time for a new automatic search, or for looking for a new update when the automatic polling is disabled. The Probe request can be invoked in two ways: the default, in which the search for update packages is done on the default server specified by the settings file, and custom way, specifying a different UpdateHub server to use during this update cycle. After executing the update process, or verifying that it does not have an update available, the machine returns to the entry point and proceeds to the configured flow. To invoke the Probe request : http://updatehub_agent:port/probe The command above start the Probe request default, to customize the local of probe, after add: { \"custom_server\": \"http://different-address:8080\" } Abort download request \u00b6 The Abort download request is solicited by the user and interrupts the download\u2019s activities, either from Download state or the Direct download state . After interrupting the download tasks running, the machine\u2019s control returns to the Entry point state . Abort download request is useful when the user wants to put off an update, or correct the address of search. The command below abort the download: http://updatehub_agent:port/update/download/abort Others API requests \u00b6 In addition to the requests presented above, the API also has others, among them the Log request and Info request . Both do not affect the machine\u2019s behavior but provide the info about the state machine. Log request \u00b6 The Log request provides information on the execution of the last state runned that is stored in the device\u2019s memory. To request the log just type: http://updatehub_agent:port/log Info request \u00b6 The Info request provides the machine\u2019s general information. The command below requests the agent's information: http://updatehub_agent:port/info","title":"The State Machine and the Flows"},{"location":"updatehub-agent/state-machine/#default-behavior","text":"The UpdateHub Agent has two operation modes: it can automatically search for new updates on a pre-setted interval. It can also work in an idle mode where searching or installing an update is only triggered by an external interaction. These two different workflows are triggered by the configuration file that the agent reads upon starting. The other workflows are triggered by requests from an external HTTP API that the agent will be listening to, coming from the CLI application, or another program that wants to interact with the UpdateHub Agent .","title":"Default behavior"},{"location":"updatehub-agent/state-machine/#automatic-search","text":"The primary usage of the Updatehub Agent is to check for updates in the UpdateHub Cloud server automatically. In this workflow, the agent can work without any interaction from the external API. When the UpdateHub Agent is started, it goes to the Entry point state . This state verifies the settings of the machine for the next transition state. The next stage is the Poll state , where the agent calculates how much time it should wait until checking with the server if there\u2019s an update available. The machine then goes to the Probe state and awaits the appropriate time before checking for new updates on the server. When it is time to access the server to check for an update, the Probe state is activated, and it accesses the UpdateHub Cloud and searches for some new update\u2019s data. If no update is available, the machine goes back to the Entry point state . When an update is available on the server, the Validation state is activated and checks the authenticity of the update\u2019s data. The Validation state also verifies whether the device has the necessary storage space for the update process. Following that, the Download state then downloads all the required data, checking the integrity of the packages, and the Install state installs the data on the proper partition of the device\u2019s storage. By the end of the installation, the device is rebooted. After rebooting, the agent begins at the Entry point state again and restarts a new cycle. In case of an error in Probe , Valitation , Download , Install , or Reboot , the Error state is triggered. The Error state allows the user to use the callback to handle situations. For more information about it, see in the Callback session.","title":"Automatic search"},{"location":"updatehub-agent/state-machine/#no-automatic-search","text":"When the automatic search is disabled, the UpdateHub Agent behaves passively, relying on external requests to inquire for new updates. This mode is useful when the user wants to control the exact time of updates according to his needs and spend fewer device resources, such as energy. When a new request comes, the machine's control changes from the Park state to the requested state and the remainder of the process is the same as the normal state execution. The way to communicate to the Updatehub Agent is through the external HTTP API. The API offers a set of requests for the user to interact with the agent\u2019s flow. We now show the execution flows for these requests.","title":"No automatic search"},{"location":"updatehub-agent/state-machine/#api-requests","text":"The API has a set of calls that allows the user to interact with the UpdateHub Agent , and here we\u2019ll present them. Regarding the update process, there are the Direct download request and the Local install request . Besides them, the Probe request that when the control is in a preemptive state, give it back to the Probe state . We follow the Abort download request that aborts any download\u2019s process, default, or direct. And lastly, we will show two requests that provide information about the state machine, the Info request and the Log request .","title":"API requests"},{"location":"updatehub-agent/state-machine/#direct-download-request","text":"In this process, the agent receives the Direct download request . The server of search is defined using a link to an alternative server or other location where the uhupkg (update package compatible with the UpdateHub Agent ) is available. Subsequently, the Prepare local install state performs the necessary tasks of space and resources validation, such as storage. With the completion of these activities, the Install state is executed, installing the essential data and deallocating resources that are no longer needed for the process. Finally, the device is restarted with the new image running the Reboot state . Set the URL to the desired location: { \"url\": \"https://some_remote_url.domain/update.uhupkg\" } So, to activate the Direct download request use the command: http://updatehub_agent:port/remote_install","title":"Direct download request"},{"location":"updatehub-agent/state-machine/#local-install-request","text":"When the UpdateHub Agent receives the Local install request , the update package should already be available on local storage on the device. This can be done with a pen-drive, for example, and requires direct user interference on the device. So, the Prepare local install state verifies the authentication, data integrity and the space available on the device\u2019s storage. It reserves the necessary resources for installation and calls the Install state to proceed with the installation. The device is then rebooted into the newly installed image. The path of the uhupkg file is required, as shown below: { \"file\": \"/tmp/updatehub-image-qa-uh-qemu-x86-64.uhupkg\" } Later, just type: http://updatehub_agent:port/local_install","title":"Local install request"},{"location":"updatehub-agent/state-machine/#probe-request","text":"The Probe request can be accepted during any preemptive state and it returns the control to the Probe state . The purpose of interrupt the flow and sending the state machine control from preemptive state to Probe state is that it is possible to start the update process, without waiting for the time for a new automatic search, or for looking for a new update when the automatic polling is disabled. The Probe request can be invoked in two ways: the default, in which the search for update packages is done on the default server specified by the settings file, and custom way, specifying a different UpdateHub server to use during this update cycle. After executing the update process, or verifying that it does not have an update available, the machine returns to the entry point and proceeds to the configured flow. To invoke the Probe request : http://updatehub_agent:port/probe The command above start the Probe request default, to customize the local of probe, after add: { \"custom_server\": \"http://different-address:8080\" }","title":"Probe request"},{"location":"updatehub-agent/state-machine/#abort-download-request","text":"The Abort download request is solicited by the user and interrupts the download\u2019s activities, either from Download state or the Direct download state . After interrupting the download tasks running, the machine\u2019s control returns to the Entry point state . Abort download request is useful when the user wants to put off an update, or correct the address of search. The command below abort the download: http://updatehub_agent:port/update/download/abort","title":"Abort download request"},{"location":"updatehub-agent/state-machine/#others-api-requests","text":"In addition to the requests presented above, the API also has others, among them the Log request and Info request . Both do not affect the machine\u2019s behavior but provide the info about the state machine.","title":"Others API requests"},{"location":"updatehub-agent/state-machine/#log-request","text":"The Log request provides information on the execution of the last state runned that is stored in the device\u2019s memory. To request the log just type: http://updatehub_agent:port/log","title":"Log request"},{"location":"updatehub-agent/state-machine/#info-request","text":"The Info request provides the machine\u2019s general information. The command below requests the agent's information: http://updatehub_agent:port/info","title":"Info request"},{"location":"updatehub-cloud/dashboard/","text":"Through the Dashboard, you as the UpdateHub user, have a rich but simple interface with all the tools required to: Create and operate your own Products . Access Products from the Organizations you have access to. Check when new Packages are available for updates. Oversee a fleet of Devices on the field. Deploy updates via an Over-The-Air using Rollouts . Essentially, the Dashboard allows the oversight over the whole UpdateHub platform and its operations, making it easy to manage any need that you might have. To access the Dashboard functions you need to be logged in to your UpdateHub account .","title":"UpdateHub Cloud dashboard"},{"location":"updatehub-cloud/device/","text":"Handling a Device \u00b6 The Device is the system entity that stores the characteristics of a physical Device . Through these characteristics, filters can be applied during a search or when performing a Rollout . The Devices page displays the list of registered Devices for the Product . In this session we will cover: Registering a Device Listing all Devices of a Product Accessing the details of a Device Rollout history of a Device Checking out Registering a device \u00b6 A Device that uses an image with the correct layers and a set of variables necessary to support UpdateHub will be automatically registered on the system when functional, check the server for updates the first time. Besides UpdateHub keys, we can create a RSA Key for additional security in communication. Listing all Devices of a Product \u00b6 When you access the subsection Device within a Product , all Devices registered for that Product will be listed. UpdateHub also allows the use of filters, guaranteeing the user an excellent organizational capacity, even when managing a large number of Devices at the same time. Accessing the details of a Device \u00b6 When you click on one of the listed Devices , the Device details page loads and will provide access to detailed information about a specific Device , such as: The Unique Identifier (UID) The Device identity values (e.g. MAC* address, CPU serial number, or other) Current installed Package version Hardware model Device state (enabled or disabled) Device attributes Latest Rollout update Rollout history of a Device \u00b6 The Rollout history of the Device allows easy access to the current and previous Device's update status, such as duration, logs about errors, and date of the events. During a normal situation the Device the Rollout will be displayed showing the moment that started, going through all the process until the point that is finished, like in the image below: In the case of some kind of problem that happens during the update process, the UpdateHub will provide visual feedback of the moment it occurred. To examine the failure you need to select See Device Log . This data about the Devices ensures the user has all information needed for any upcoming situation, being capable of managing his Devices within the entire Product lifetime. Checking out \u00b6 To check if the Rollout worked and the Devices is up to date you just need to type in your Devices the command below. cat /etc/os-release And the version you use in Rollout will be shown.","title":"Handling a Device"},{"location":"updatehub-cloud/device/#handling-a-device","text":"The Device is the system entity that stores the characteristics of a physical Device . Through these characteristics, filters can be applied during a search or when performing a Rollout . The Devices page displays the list of registered Devices for the Product . In this session we will cover: Registering a Device Listing all Devices of a Product Accessing the details of a Device Rollout history of a Device Checking out","title":"Handling a Device"},{"location":"updatehub-cloud/device/#registering-a-device","text":"A Device that uses an image with the correct layers and a set of variables necessary to support UpdateHub will be automatically registered on the system when functional, check the server for updates the first time. Besides UpdateHub keys, we can create a RSA Key for additional security in communication.","title":"Registering a device"},{"location":"updatehub-cloud/device/#listing-all-devices-of-a-product","text":"When you access the subsection Device within a Product , all Devices registered for that Product will be listed. UpdateHub also allows the use of filters, guaranteeing the user an excellent organizational capacity, even when managing a large number of Devices at the same time.","title":"Listing all Devices of a Product"},{"location":"updatehub-cloud/device/#accessing-the-details-of-a-device","text":"When you click on one of the listed Devices , the Device details page loads and will provide access to detailed information about a specific Device , such as: The Unique Identifier (UID) The Device identity values (e.g. MAC* address, CPU serial number, or other) Current installed Package version Hardware model Device state (enabled or disabled) Device attributes Latest Rollout update","title":"Accessing the details of a Device"},{"location":"updatehub-cloud/device/#rollout-history-of-a-device","text":"The Rollout history of the Device allows easy access to the current and previous Device's update status, such as duration, logs about errors, and date of the events. During a normal situation the Device the Rollout will be displayed showing the moment that started, going through all the process until the point that is finished, like in the image below: In the case of some kind of problem that happens during the update process, the UpdateHub will provide visual feedback of the moment it occurred. To examine the failure you need to select See Device Log . This data about the Devices ensures the user has all information needed for any upcoming situation, being capable of managing his Devices within the entire Product lifetime.","title":"Rollout history of a Device"},{"location":"updatehub-cloud/device/#checking-out","text":"To check if the Rollout worked and the Devices is up to date you just need to type in your Devices the command below. cat /etc/os-release And the version you use in Rollout will be shown.","title":"Checking out"},{"location":"updatehub-cloud/menu/","text":"Your menu account \u00b6 In the menu we have your account information, access keys applicable to the configuration of UpdateHub on devices, Organizations and Billing . Your account menu is at the top right of the Dashboard . In this session we will cover: Acessing settings Account personal data Applications access Requesting a access key Organization Creating an Organization More about the Billing Acessing settings \u00b6 At the Settings menu you will find your information, and you will be able to manage your Account , the Aplication Access , as well as manage the Organizations you belongs to. Sign in your account and go to settings screen by clicking on the drop down menu on the right of your name and select Settings . Account personal data \u00b6 The account subsection shows your current data and allows you to edit them or add a new email. Applications access \u00b6 To authenticate and authorize requests for a project build with the UpdateHub you must have a security credential in the form of an application access key. Each access key is specific to your user and is used to upload the packages or any other external integration which needs to access the UpdateHub API. In this section all access keys for your account will be listed. Requesting a access key \u00b6 If you need to, you can create a new one by clicking the + Request Access Key button. Choose a name for the key and select the API Key owner as Me or a Organization . Once the Access Key is created a dialog will appear to show the security credentials. Save your keys On the moment that this window is closed the keys will not be shown again and if you lose them you must revoke the Access Key and generate a new one. Organization \u00b6 In addition to the Access Key created for the user to work individually, the UpdateHub grants the possibility of more than one user to have access to the same Product throught of an Organization . Creating an Organization \u00b6 Create an Organization is simple, as you just need to click on the + Create Organization button and select a name for it. You will be automatically be set as Owner . After the creation of an Organization invitations for new members can be easily sent. The invite must contain the user's e-mail and the level of access allowed to him. There are three users access levels inside the Organization , each one with a particular set of permissions: Owner - has all the permissions to normally create Products , start Rollouts and invite other members for the Organization . Release Manager - limited to manage the Rollouts . Developer - has the permission to only create the Packages . Each Organization will display a list with all of its members, showing their name, e-mail address, access level of permission, and a list with all the pending invites waiting to be answered. More about the Billing \u00b6 The UpdateHub Cloud allows the registration of up to 5 devices in your account without any type of charge. Above this number, the server will not allow more devices to be registered in this account, which can generate an error when a device configured with UpdateHub support tries to access the server. To enable the support for more devices, you need to upgrade your account, accessing the Unlock Unlimited Usage at Billing and enter the requested data. The billing is split upon: My usage - about the Products that the owner is the user of the account, that is, they were created by this account with the Owner as Me . My organizations - that is generated by Products that belong to an Organization created by the account user. Billing for an organization is generated in the Owner account for that organization, and each organization generates a separate billing. If you want more informations about values, Estimate your costs will help you.","title":"Your menu account"},{"location":"updatehub-cloud/menu/#your-menu-account","text":"In the menu we have your account information, access keys applicable to the configuration of UpdateHub on devices, Organizations and Billing . Your account menu is at the top right of the Dashboard . In this session we will cover: Acessing settings Account personal data Applications access Requesting a access key Organization Creating an Organization More about the Billing","title":"Your menu account"},{"location":"updatehub-cloud/menu/#acessing-settings","text":"At the Settings menu you will find your information, and you will be able to manage your Account , the Aplication Access , as well as manage the Organizations you belongs to. Sign in your account and go to settings screen by clicking on the drop down menu on the right of your name and select Settings .","title":"Acessing settings"},{"location":"updatehub-cloud/menu/#account-personal-data","text":"The account subsection shows your current data and allows you to edit them or add a new email.","title":"Account personal data"},{"location":"updatehub-cloud/menu/#applications-access","text":"To authenticate and authorize requests for a project build with the UpdateHub you must have a security credential in the form of an application access key. Each access key is specific to your user and is used to upload the packages or any other external integration which needs to access the UpdateHub API. In this section all access keys for your account will be listed.","title":"Applications access"},{"location":"updatehub-cloud/menu/#requesting-a-access-key","text":"If you need to, you can create a new one by clicking the + Request Access Key button. Choose a name for the key and select the API Key owner as Me or a Organization . Once the Access Key is created a dialog will appear to show the security credentials. Save your keys On the moment that this window is closed the keys will not be shown again and if you lose them you must revoke the Access Key and generate a new one.","title":"Requesting a access key"},{"location":"updatehub-cloud/menu/#organization","text":"In addition to the Access Key created for the user to work individually, the UpdateHub grants the possibility of more than one user to have access to the same Product throught of an Organization .","title":"Organization"},{"location":"updatehub-cloud/menu/#creating-an-organization","text":"Create an Organization is simple, as you just need to click on the + Create Organization button and select a name for it. You will be automatically be set as Owner . After the creation of an Organization invitations for new members can be easily sent. The invite must contain the user's e-mail and the level of access allowed to him. There are three users access levels inside the Organization , each one with a particular set of permissions: Owner - has all the permissions to normally create Products , start Rollouts and invite other members for the Organization . Release Manager - limited to manage the Rollouts . Developer - has the permission to only create the Packages . Each Organization will display a list with all of its members, showing their name, e-mail address, access level of permission, and a list with all the pending invites waiting to be answered.","title":"Creating an Organization"},{"location":"updatehub-cloud/menu/#more-about-the-billing","text":"The UpdateHub Cloud allows the registration of up to 5 devices in your account without any type of charge. Above this number, the server will not allow more devices to be registered in this account, which can generate an error when a device configured with UpdateHub support tries to access the server. To enable the support for more devices, you need to upgrade your account, accessing the Unlock Unlimited Usage at Billing and enter the requested data. The billing is split upon: My usage - about the Products that the owner is the user of the account, that is, they were created by this account with the Owner as Me . My organizations - that is generated by Products that belong to an Organization created by the account user. Billing for an organization is generated in the Owner account for that organization, and each organization generates a separate billing. If you want more informations about values, Estimate your costs will help you.","title":"More about the Billing"},{"location":"updatehub-cloud/package-rollout/","text":"As Package and Rollout are strictly linked, we chose to address both in a single section. In summary, we can say that a Rollout is the process of applying a Package to certain Devices but in subsections below more detailed description is given. Manipulating a Package \u00b6 A Package is an update that will add or remove information to an image that is running on a Device that is in the field. First, a modified image will be sent to the server with a specific command (see more in uhupkg), and then it is available in the Package subsection, becoming available to be selected in a new Rollout. In Dashboard , the Package is available after you join in a specific Product . In this session we will cover: Viewing the Package list More informations about a Package Viewing the Package list \u00b6 The Packages page, in the same fashion, as the Devices page, exhibit a list with information about the Packages inside a specific Product the user selected, such as: Package Unique Identifier (UID) Version Supported hardware list Status Size Upload date Each one of these items helps the user find a specific Package . To filter more efficiently the Packages you can select and associate them with the following items during the search: Status of each Packages can be found depending on the situation for the Rollout Available : the Packages is ready to be downloaded Upload in Progress : Packages during the uploaded process Removed : Packages that were removed from the Packages list Pending Progress : Packages being checked by the server Packages with Error : Packages that failed the system checksum Version for the Package Supported hardware More information about a Package \u00b6 On the Package Details page the user may have a deeper look into a particular Package and its information. Beyond the information already present on the Package List , you will find more data about the Objects and their details which are used by the UpdateHub agent during the object's installation. Once you entered the Package Details you have the option to remove the Package from the Rollout if necessary by clicking on the trash can icon. The Package will be visible and accessible but won't be available anymore. Administering a Rollout \u00b6 Rollout is the process of sending updates from the server to the Devices registered in a certain Product . To start a Rollout , the update Package must be sent to the server and then the process can be initiated by Product overview or by the subsection Rollout . In this session we will cover: Ways to create a Rollout All Devices Select the target Devices Register of Rollout Detailing a Rollout Ways to create a Rollout \u00b6 There are two methods to execute the Rollout : the simpler way is to update all the versions of the Devices present on the field at once. The other way is to select which Devices receive the update through the Advanced Mode option. All Devices \u00b6 To update all Devices in the field to the same version you just need to go to the Overview or Rollouts page and click on Create Rollout . A box to choose the version will appear. After you make this choice just click on Save to initiate the Rollout later or Save and Start launch it straight away. Select the target Devices \u00b6 The other way is to select which equipment receives the Rollout is using the Advanced Mode option that allows the use of selection filters for Devices . In Advanced Mode , you can create and name tasks that define the filters that will be applied, selecting which Devices will receive the update. In addition to the available filters, UpdateHub provides Fault Tolerance , which is a percentage that can be set by the user to abort the Rollout automatically if the failure rate exceeds the specified limit. It is advised to use Fault Tolerance percentage because this is the safety measure. The Devices can be filtered by their Version, Hardware, Devices Identifier (e.g: the MAC address), and Devices Attributes (e.g: kernel version, device total memory). Finally, Save the Rollout to start later or Save and Start it immediately. Register of Rollouts \u00b6 The Rollout List exhibits every Rollout available for the Product chosen and brief information about them, such as name, version, creation, status, and progress. Detailing a Rollout \u00b6 The UpdateHub also gives all the information in detail of each specific Rollout , allowing a complete overview of the individual process. Among the information displayed inside the Rollout Details you will find: Version : the version of Rollout that the Device will receive Creation Date : the date that the Rollout was created Tasks : this area shows each task that is part of the Rollout . Each task includes very information, such as: Number of Devices : all the Devices available for the Rollout , including the number of processes concluded, failed, and remaining in one or various tasks are displayed here Fault tolerance : that's the percentage limit of failures that can occur during the Rollout until the UpdateHub aborts the running Rollout process, including any pending tasks Play/Pause Rollout : whenever the user wants to play or pause the Rollout the option is available unless the process is aborted or the user chooses to archive it Archive the Rollout : once the Rollout is not necessary anymore it can be archived and stopped definitely","title":"Package and Rollout"},{"location":"updatehub-cloud/package-rollout/#manipulating-a-package","text":"A Package is an update that will add or remove information to an image that is running on a Device that is in the field. First, a modified image will be sent to the server with a specific command (see more in uhupkg), and then it is available in the Package subsection, becoming available to be selected in a new Rollout. In Dashboard , the Package is available after you join in a specific Product . In this session we will cover: Viewing the Package list More informations about a Package","title":"Manipulating a Package"},{"location":"updatehub-cloud/package-rollout/#viewing-the-package-list","text":"The Packages page, in the same fashion, as the Devices page, exhibit a list with information about the Packages inside a specific Product the user selected, such as: Package Unique Identifier (UID) Version Supported hardware list Status Size Upload date Each one of these items helps the user find a specific Package . To filter more efficiently the Packages you can select and associate them with the following items during the search: Status of each Packages can be found depending on the situation for the Rollout Available : the Packages is ready to be downloaded Upload in Progress : Packages during the uploaded process Removed : Packages that were removed from the Packages list Pending Progress : Packages being checked by the server Packages with Error : Packages that failed the system checksum Version for the Package Supported hardware","title":"Viewing the Package list"},{"location":"updatehub-cloud/package-rollout/#more-information-about-a-package","text":"On the Package Details page the user may have a deeper look into a particular Package and its information. Beyond the information already present on the Package List , you will find more data about the Objects and their details which are used by the UpdateHub agent during the object's installation. Once you entered the Package Details you have the option to remove the Package from the Rollout if necessary by clicking on the trash can icon. The Package will be visible and accessible but won't be available anymore.","title":"More information about a Package"},{"location":"updatehub-cloud/package-rollout/#administering-a-rollout","text":"Rollout is the process of sending updates from the server to the Devices registered in a certain Product . To start a Rollout , the update Package must be sent to the server and then the process can be initiated by Product overview or by the subsection Rollout . In this session we will cover: Ways to create a Rollout All Devices Select the target Devices Register of Rollout Detailing a Rollout","title":"Administering a Rollout"},{"location":"updatehub-cloud/package-rollout/#ways-to-create-a-rollout","text":"There are two methods to execute the Rollout : the simpler way is to update all the versions of the Devices present on the field at once. The other way is to select which Devices receive the update through the Advanced Mode option.","title":"Ways to create a Rollout"},{"location":"updatehub-cloud/package-rollout/#all-devices","text":"To update all Devices in the field to the same version you just need to go to the Overview or Rollouts page and click on Create Rollout . A box to choose the version will appear. After you make this choice just click on Save to initiate the Rollout later or Save and Start launch it straight away.","title":"All Devices"},{"location":"updatehub-cloud/package-rollout/#select-the-target-devices","text":"The other way is to select which equipment receives the Rollout is using the Advanced Mode option that allows the use of selection filters for Devices . In Advanced Mode , you can create and name tasks that define the filters that will be applied, selecting which Devices will receive the update. In addition to the available filters, UpdateHub provides Fault Tolerance , which is a percentage that can be set by the user to abort the Rollout automatically if the failure rate exceeds the specified limit. It is advised to use Fault Tolerance percentage because this is the safety measure. The Devices can be filtered by their Version, Hardware, Devices Identifier (e.g: the MAC address), and Devices Attributes (e.g: kernel version, device total memory). Finally, Save the Rollout to start later or Save and Start it immediately.","title":"Select the target Devices"},{"location":"updatehub-cloud/package-rollout/#register-of-rollouts","text":"The Rollout List exhibits every Rollout available for the Product chosen and brief information about them, such as name, version, creation, status, and progress.","title":"Register of Rollouts"},{"location":"updatehub-cloud/package-rollout/#detailing-a-rollout","text":"The UpdateHub also gives all the information in detail of each specific Rollout , allowing a complete overview of the individual process. Among the information displayed inside the Rollout Details you will find: Version : the version of Rollout that the Device will receive Creation Date : the date that the Rollout was created Tasks : this area shows each task that is part of the Rollout . Each task includes very information, such as: Number of Devices : all the Devices available for the Rollout , including the number of processes concluded, failed, and remaining in one or various tasks are displayed here Fault tolerance : that's the percentage limit of failures that can occur during the Rollout until the UpdateHub aborts the running Rollout process, including any pending tasks Play/Pause Rollout : whenever the user wants to play or pause the Rollout the option is available unless the process is aborted or the user chooses to archive it Archive the Rollout : once the Rollout is not necessary anymore it can be archived and stopped definitely","title":"Detailing a Rollout"},{"location":"updatehub-cloud/product/","text":"Managing a Product \u00b6 A Product creation is the first step we need to do when starting to use the UpdateHub Cloud . It is required because every Device , Package or Rollout needs to be associated with a Product . In this session we will cover: How to create a product Viewing the details of a product How to create a Product \u00b6 To create a Product just go to Add product through the initial page of the Dashboard . When you access the Dashboard home page, all of your created Products will be displayed. By doing that the following dialog will be displayed. Please choose a Product name and its Owner ( Me or an Organization ). Every organization that the user has access to is available as the Owner of the Product . Bear in mind that an Organization is a group of users and that it may own one or more Product . Users who belong to an organization may have different access levels to a given Product . About the name and owner Pay attention that after you create a Product you can not rename or delete it, and you can not transfer it to an organization or vice versa, so be sure you are choosing the correct name and the owner. After the Product has been created a Unique Identifier Number ( UPDATEHUB_PRODUCT_UID ) is generated to identify it. This number should be added to your build to allow the UpdateHub Agent , which runs inside the target Device , to communicate with the UpdateHub Cloud . For convenience, you can add the UPDATEHUB_PRODUCT_UID to your build/conf/local.conf configuration file when prototyping. As this is information that will be permanent for the whole Product life cycle, it should be put inside your distribution configuration file or image recipe. After you press the OK button you will be into the Products screen where you can see all your Product , Rollouts , Devices , and Packages . If you make changes in your Product and send these changes to your UpdateHub the Package will appear in the Package List . Viewing the details of a Product \u00b6 When you access the Dashboard , the Products you have created or have access to are displayed in a list. The page appears as shown below: Clicking on any Product card, you will be taken to the Product Overview page. On this page you find useful information about the Product , as which Devices you have deployed on the field, the two last Packages sent for that particular Product and the Rollouts status. In case you didn't copy the Product Unique Identifier Number the moment that you create it on the UpdateHub Cloud , don't worry. To get access to this information again you must click on the Product icon and the Unique Identifier Number will be shown to you.","title":"Managing a Product"},{"location":"updatehub-cloud/product/#managing-a-product","text":"A Product creation is the first step we need to do when starting to use the UpdateHub Cloud . It is required because every Device , Package or Rollout needs to be associated with a Product . In this session we will cover: How to create a product Viewing the details of a product","title":"Managing a Product"},{"location":"updatehub-cloud/product/#how-to-create-a-product","text":"To create a Product just go to Add product through the initial page of the Dashboard . When you access the Dashboard home page, all of your created Products will be displayed. By doing that the following dialog will be displayed. Please choose a Product name and its Owner ( Me or an Organization ). Every organization that the user has access to is available as the Owner of the Product . Bear in mind that an Organization is a group of users and that it may own one or more Product . Users who belong to an organization may have different access levels to a given Product . About the name and owner Pay attention that after you create a Product you can not rename or delete it, and you can not transfer it to an organization or vice versa, so be sure you are choosing the correct name and the owner. After the Product has been created a Unique Identifier Number ( UPDATEHUB_PRODUCT_UID ) is generated to identify it. This number should be added to your build to allow the UpdateHub Agent , which runs inside the target Device , to communicate with the UpdateHub Cloud . For convenience, you can add the UPDATEHUB_PRODUCT_UID to your build/conf/local.conf configuration file when prototyping. As this is information that will be permanent for the whole Product life cycle, it should be put inside your distribution configuration file or image recipe. After you press the OK button you will be into the Products screen where you can see all your Product , Rollouts , Devices , and Packages . If you make changes in your Product and send these changes to your UpdateHub the Package will appear in the Package List .","title":"How to create a Product"},{"location":"updatehub-cloud/product/#viewing-the-details-of-a-product","text":"When you access the Dashboard , the Products you have created or have access to are displayed in a list. The page appears as shown below: Clicking on any Product card, you will be taken to the Product Overview page. On this page you find useful information about the Product , as which Devices you have deployed on the field, the two last Packages sent for that particular Product and the Rollouts status. In case you didn't copy the Product Unique Identifier Number the moment that you create it on the UpdateHub Cloud , don't worry. To get access to this information again you must click on the Product icon and the Unique Identifier Number will be shown to you.","title":"Viewing the details of a Product"},{"location":"yocto-project/gatesgarth/","text":"Yocto Project 3.2 (Gatesgarth) \u00b6 In the version of Yocto Project 3.2 (Gatesgarth) the following machines are supported: Commercial name Machine Layer Beaglebone Black beaglebone meta-updatehub-ti Boundary Devices Nitrogen6X nitrogen6x meta-updatehub-freescale NXP i.MX6 SABRE Automotive Board imx6qdlsabreauto meta-updatehub-freescale NXP i.MX6 SABRE Platform for Smart Devices imx6qdlsabresd meta-updatehub-freescale Raspberry Pi 0 raspberrypi0 meta-updatehub-raspberrypi Raspberry Pi 3 Model B and B+ raspberrypi3 meta-updatehub-raspberrypi Raspberry Pi 4 Model B raspberrypi4 meta-updatehub-raspberrypi TechNexion PICO i.MX7 imx7d-pico meta-updatehub-freescale Toradex Apalis iMX6 apalis-imx6 meta-updatehub-freescale Toradex Colibri iMX6 colibri-imx6 meta-updatehub-freescale Toradex Colibri iMX7 (with eMMC storage) colibri-imx7-emmc meta-updatehub-freescale Wandboard Solo/Dual/Quad wandboard meta-updatehub-freescale","title":"Gatesgarth"},{"location":"yocto-project/gatesgarth/#yocto-project-32-gatesgarth","text":"In the version of Yocto Project 3.2 (Gatesgarth) the following machines are supported: Commercial name Machine Layer Beaglebone Black beaglebone meta-updatehub-ti Boundary Devices Nitrogen6X nitrogen6x meta-updatehub-freescale NXP i.MX6 SABRE Automotive Board imx6qdlsabreauto meta-updatehub-freescale NXP i.MX6 SABRE Platform for Smart Devices imx6qdlsabresd meta-updatehub-freescale Raspberry Pi 0 raspberrypi0 meta-updatehub-raspberrypi Raspberry Pi 3 Model B and B+ raspberrypi3 meta-updatehub-raspberrypi Raspberry Pi 4 Model B raspberrypi4 meta-updatehub-raspberrypi TechNexion PICO i.MX7 imx7d-pico meta-updatehub-freescale Toradex Apalis iMX6 apalis-imx6 meta-updatehub-freescale Toradex Colibri iMX6 colibri-imx6 meta-updatehub-freescale Toradex Colibri iMX7 (with eMMC storage) colibri-imx7-emmc meta-updatehub-freescale Wandboard Solo/Dual/Quad wandboard meta-updatehub-freescale","title":"Yocto Project 3.2 (Gatesgarth)"},{"location":"yocto-project/glossary/","text":"Glossary of variables \u00b6 UPDATEHUB_ACCESS_SECRET \u00b6 When using the uhupush task we can override the Access Id and the corresponding Secret for use. This is usually used in auto builders as they may require different credentials depending on the product being build. UPDATEHUB_ACTIVE_INACTIVE_BACKEND \u00b6 The active and inactive image schema requires a backend to identify and choose the image to be used for next boot. It supports: u-boot , grub or grub-efi . UPDATEHUB_CUSTOM_CA_CERTS \u00b6 Specify the CA certificate bundle to be used for uhupush task. It is currently used by UpdateHub staging server for tests but may be interesting for other users when doing custom server deployments. UPDATEHUB_DEVICE_ATTRIBUTE \u00b6 This allows more details to be added on a device. This is a very useful variable to applying filters to certain devices. Some examples of attributes: kernel , cpu-model , mem-total and ipinfo-io . UPDATEHUB_DEVICE_IDENTITY \u00b6 This variable provides the device with an identity, making it easier to recognize each device during operations on UpdateHub Cloud . The supported values \u200b\u200bare: primary-iface : is the MAC of the primary network interface. cpuinfo-serial : It is the serial number of the processor, can be obtained with the command \"grep Serial / proc / cpuinfo\". custom : parameter that you can create. To create a customized parameter, simply put UPDATEHUB_DEVICE_IDENTITY + _ (underscore) + name such as UPDATEHUB_DEVICE_IDENTITY_updatehub-imx or UPDATEHUB_DEVICE_IDENTITY_updatehub-rpi. UPDATEHUB_FILESYSTEM_SUPPORT \u00b6 When using the copy or tarball installation mode, some filesystem support packages are required. This variable controls which filesystems should be supported. It supports different values, as btrfs , ext2 , ext3 , ext4 , f2fs , jffs2 , ubifs , vfat and xfs . UPDATEHUB_IMAGE_TYPE \u00b6 The updatehub can operate using different setup which can be chosen using the UPDATEHUB_IMAGE_TYPE variable. It supports different values, as below: initramfs - Enables the Updatehub gold firmware support; this adds an initramfs based image which is used for the upgrade process. In this mode, the Updatehub Agent is ran inside an initramfs image which allows for the image to be changed without the need of a spare storage space. active/inactive - Allow the use of active and inactive images schema. This reduces the downtime of the system as the image can be change without rebooting. The new image is installed in a spare storage area and in next reboot the new image is used. The UPDATEHUB_ACTIVE_INACTIVE_BACKEND variable need to set depending of the machine requirement. UPDATEHUB_INSTALL_MODE \u00b6 There are multiple installation modes supported. This is usually machine dependent as it depends on the storate type in use. Supported values are: copy , flash , raw , tarball , ubifs and imxkobs . UPDATEHUB_PACKAGE_VERSION \u00b6 Informs the system version and is based on the Yocto Project's DISTRO_VERSION variable (the version of the distribution). UPDATEHUB_PACKAGE_VERSION_SUFFIX \u00b6 It allows adding more information at the end of the variable name. UPDATEHUB_PRODUCT_UID \u00b6 The UPDATEHUB_PRODUCT_UID identifies the product id in use. This is used by the Updatehub server to identify the product and track the possible versions for Rollouts. UPDATEHUB_RUNTIME_PACKAGES \u00b6 Is a variable configured to install some package in an image that supports UpdateHub , such as an boot configuration package or to install a bootscript. UPDATEHUB_SERVER_URL \u00b6 Specifies the Updatehub server address to use. This is required in case you are running it inside your private cloud. UPDATEHUB_UHUPKG_PRIVATE_KEY \u00b6 The variable are required to point to the private key which are used to validate and sign the update package. The private key works together with the public key that is described below in UPDATEHUB_UHUPKG_PUBLIC_KEY, variable that points to the private key. The keys may or not be stored on the layer. Commonly the keys are not available for developers and passed to the build system using the local.conf file of the autobuilder. UPDATEHUB_UHUPKG_PUBLIC_KEY \u00b6 The variable to point to public key that work in conjunction with the private key to ensure more security in authentication. The keys may or not be stored on the layer. Commonly the keys are not available for developers and passed to the build system using the local.conf file of the autobuilder.","title":"Glossary of variables"},{"location":"yocto-project/glossary/#glossary-of-variables","text":"","title":"Glossary of variables"},{"location":"yocto-project/glossary/#updatehub_access_secret","text":"When using the uhupush task we can override the Access Id and the corresponding Secret for use. This is usually used in auto builders as they may require different credentials depending on the product being build.","title":"UPDATEHUB_ACCESS_SECRET"},{"location":"yocto-project/glossary/#updatehub_active_inactive_backend","text":"The active and inactive image schema requires a backend to identify and choose the image to be used for next boot. It supports: u-boot , grub or grub-efi .","title":"UPDATEHUB_ACTIVE_INACTIVE_BACKEND"},{"location":"yocto-project/glossary/#updatehub_custom_ca_certs","text":"Specify the CA certificate bundle to be used for uhupush task. It is currently used by UpdateHub staging server for tests but may be interesting for other users when doing custom server deployments.","title":"UPDATEHUB_CUSTOM_CA_CERTS"},{"location":"yocto-project/glossary/#updatehub_device_attribute","text":"This allows more details to be added on a device. This is a very useful variable to applying filters to certain devices. Some examples of attributes: kernel , cpu-model , mem-total and ipinfo-io .","title":"UPDATEHUB_DEVICE_ATTRIBUTE"},{"location":"yocto-project/glossary/#updatehub_device_identity","text":"This variable provides the device with an identity, making it easier to recognize each device during operations on UpdateHub Cloud . The supported values \u200b\u200bare: primary-iface : is the MAC of the primary network interface. cpuinfo-serial : It is the serial number of the processor, can be obtained with the command \"grep Serial / proc / cpuinfo\". custom : parameter that you can create. To create a customized parameter, simply put UPDATEHUB_DEVICE_IDENTITY + _ (underscore) + name such as UPDATEHUB_DEVICE_IDENTITY_updatehub-imx or UPDATEHUB_DEVICE_IDENTITY_updatehub-rpi.","title":"UPDATEHUB_DEVICE_IDENTITY"},{"location":"yocto-project/glossary/#updatehub_filesystem_support","text":"When using the copy or tarball installation mode, some filesystem support packages are required. This variable controls which filesystems should be supported. It supports different values, as btrfs , ext2 , ext3 , ext4 , f2fs , jffs2 , ubifs , vfat and xfs .","title":"UPDATEHUB_FILESYSTEM_SUPPORT"},{"location":"yocto-project/glossary/#updatehub_image_type","text":"The updatehub can operate using different setup which can be chosen using the UPDATEHUB_IMAGE_TYPE variable. It supports different values, as below: initramfs - Enables the Updatehub gold firmware support; this adds an initramfs based image which is used for the upgrade process. In this mode, the Updatehub Agent is ran inside an initramfs image which allows for the image to be changed without the need of a spare storage space. active/inactive - Allow the use of active and inactive images schema. This reduces the downtime of the system as the image can be change without rebooting. The new image is installed in a spare storage area and in next reboot the new image is used. The UPDATEHUB_ACTIVE_INACTIVE_BACKEND variable need to set depending of the machine requirement.","title":"UPDATEHUB_IMAGE_TYPE"},{"location":"yocto-project/glossary/#updatehub_install_mode","text":"There are multiple installation modes supported. This is usually machine dependent as it depends on the storate type in use. Supported values are: copy , flash , raw , tarball , ubifs and imxkobs .","title":"UPDATEHUB_INSTALL_MODE"},{"location":"yocto-project/glossary/#updatehub_package_version","text":"Informs the system version and is based on the Yocto Project's DISTRO_VERSION variable (the version of the distribution).","title":"UPDATEHUB_PACKAGE_VERSION"},{"location":"yocto-project/glossary/#updatehub_package_version_suffix","text":"It allows adding more information at the end of the variable name.","title":"UPDATEHUB_PACKAGE_VERSION_SUFFIX"},{"location":"yocto-project/glossary/#updatehub_product_uid","text":"The UPDATEHUB_PRODUCT_UID identifies the product id in use. This is used by the Updatehub server to identify the product and track the possible versions for Rollouts.","title":"UPDATEHUB_PRODUCT_UID"},{"location":"yocto-project/glossary/#updatehub_runtime_packages","text":"Is a variable configured to install some package in an image that supports UpdateHub , such as an boot configuration package or to install a bootscript.","title":"UPDATEHUB_RUNTIME_PACKAGES"},{"location":"yocto-project/glossary/#updatehub_server_url","text":"Specifies the Updatehub server address to use. This is required in case you are running it inside your private cloud.","title":"UPDATEHUB_SERVER_URL"},{"location":"yocto-project/glossary/#updatehub_uhupkg_private_key","text":"The variable are required to point to the private key which are used to validate and sign the update package. The private key works together with the public key that is described below in UPDATEHUB_UHUPKG_PUBLIC_KEY, variable that points to the private key. The keys may or not be stored on the layer. Commonly the keys are not available for developers and passed to the build system using the local.conf file of the autobuilder.","title":"UPDATEHUB_UHUPKG_PRIVATE_KEY"},{"location":"yocto-project/glossary/#updatehub_uhupkg_public_key","text":"The variable to point to public key that work in conjunction with the private key to ensure more security in authentication. The keys may or not be stored on the layer. Commonly the keys are not available for developers and passed to the build system using the local.conf file of the autobuilder.","title":"UPDATEHUB_UHUPKG_PUBLIC_KEY"},{"location":"yocto-project/krogoth/","text":"Yocto Project 2.1 (Krogoth) \u00b6 In the version of Yocto Project 2.1 (Krogoth) the following machines are supported: Commercial name Machine Layer Beaglebone Black beaglebone meta-updatehub-ti Boundary Devices Nitrogen6X nitrogen6x meta-updatehub-freescale NXP i.MX6 Dual SABRE Automotive Board imx6dlsabreauto meta-updatehub-freescale NXP i.MX6 Dual SABRE Platform for Smart Devices imx6dlsabresd meta-updatehub-freescale NXP i.MX6 Quad SABRE Automotive Board imx6qsabreauto meta-updatehub-freescale NXP i.MX6 Quad SABRE Platform for Smart Devices imx6qsabresd meta-updatehub-freescale Raspberry Pi 3 Model B and B+ raspberrypi3 meta-updatehub-raspberrypi Wandboard Solo/Dual/Quad wandboard meta-updatehub-freescale","title":"Krogoth"},{"location":"yocto-project/krogoth/#yocto-project-21-krogoth","text":"In the version of Yocto Project 2.1 (Krogoth) the following machines are supported: Commercial name Machine Layer Beaglebone Black beaglebone meta-updatehub-ti Boundary Devices Nitrogen6X nitrogen6x meta-updatehub-freescale NXP i.MX6 Dual SABRE Automotive Board imx6dlsabreauto meta-updatehub-freescale NXP i.MX6 Dual SABRE Platform for Smart Devices imx6dlsabresd meta-updatehub-freescale NXP i.MX6 Quad SABRE Automotive Board imx6qsabreauto meta-updatehub-freescale NXP i.MX6 Quad SABRE Platform for Smart Devices imx6qsabresd meta-updatehub-freescale Raspberry Pi 3 Model B and B+ raspberrypi3 meta-updatehub-raspberrypi Wandboard Solo/Dual/Quad wandboard meta-updatehub-freescale","title":"Yocto Project 2.1 (Krogoth)"},{"location":"yocto-project/morty/","text":"Yocto Project 2.2 (Morty) \u00b6 In the version of Yocto Project 2.2 (Morty) the following machines are supported: Commercial name Machine Layer Beaglebone Black beaglebone meta-updatehub-ti Boundary Devices Nitrogen6X nitrogen6x meta-updatehub-freescale NXP i.MX6 Dual SABRE Platform for Smart Devices imx6dlsabreauto meta-updatehub-freescale NXP i.MX6 Dual SABRE Platform for Smart Devices imxdlsabresd meta-updatehub-freescale NXP i.MX6 Quad SABRE Automotive Board imx6qsabreauto meta-updatehub-freescale NXP i.MX6 Quad SABRE Automotive Board imx6qsabresd meta-updatehub-freescale Raspberry Pi 3 Model B and B+ raspberrypi3 meta-updatehub-raspberrypi Wandboard Solo/Dual/Quad wandboard meta-updatehub-freescale","title":"Morty"},{"location":"yocto-project/morty/#yocto-project-22-morty","text":"In the version of Yocto Project 2.2 (Morty) the following machines are supported: Commercial name Machine Layer Beaglebone Black beaglebone meta-updatehub-ti Boundary Devices Nitrogen6X nitrogen6x meta-updatehub-freescale NXP i.MX6 Dual SABRE Platform for Smart Devices imx6dlsabreauto meta-updatehub-freescale NXP i.MX6 Dual SABRE Platform for Smart Devices imxdlsabresd meta-updatehub-freescale NXP i.MX6 Quad SABRE Automotive Board imx6qsabreauto meta-updatehub-freescale NXP i.MX6 Quad SABRE Automotive Board imx6qsabresd meta-updatehub-freescale Raspberry Pi 3 Model B and B+ raspberrypi3 meta-updatehub-raspberrypi Wandboard Solo/Dual/Quad wandboard meta-updatehub-freescale","title":"Yocto Project 2.2 (Morty)"},{"location":"yocto-project/pyro/","text":"Yocto Project 2.3 (Pyro) \u00b6 In the version of Yocto Project 2.3 (Pyro) the following machines are supported: Commercial name Machine Layer Beaglebone Black beaglebone meta-updatehub-ti Boundary Devices Nitrogen6X nitrogen6x meta-updatehub-freescale NXP i.MX6 Dual SABRE Automotive Board imx6dlsabreauto meta-updatehub-freescale NXP i.MX6 Dual SABRE Platform for Smart Devices imx6dlsabresd meta-updatehub-freescale NXP i.MX6 Quad SABRE Automotive Board imx6qsabreauto meta-updatehub-freescale NXP i.MX6 Quad SABRE Platform for Smart Devices imx6qsabresd meta-updatehub-freescale Raspberry Pi 3 Model B and B+ raspberrypi3 meta-updatehub-raspberrypi Toradex Apalis iMX6 apalis-imx6 meta-updatehub-freescale Wandboard Solo/Dual/Quad wandboard meta-updatehub-freescale","title":"Pyro"},{"location":"yocto-project/pyro/#yocto-project-23-pyro","text":"In the version of Yocto Project 2.3 (Pyro) the following machines are supported: Commercial name Machine Layer Beaglebone Black beaglebone meta-updatehub-ti Boundary Devices Nitrogen6X nitrogen6x meta-updatehub-freescale NXP i.MX6 Dual SABRE Automotive Board imx6dlsabreauto meta-updatehub-freescale NXP i.MX6 Dual SABRE Platform for Smart Devices imx6dlsabresd meta-updatehub-freescale NXP i.MX6 Quad SABRE Automotive Board imx6qsabreauto meta-updatehub-freescale NXP i.MX6 Quad SABRE Platform for Smart Devices imx6qsabresd meta-updatehub-freescale Raspberry Pi 3 Model B and B+ raspberrypi3 meta-updatehub-raspberrypi Toradex Apalis iMX6 apalis-imx6 meta-updatehub-freescale Wandboard Solo/Dual/Quad wandboard meta-updatehub-freescale","title":"Yocto Project 2.3 (Pyro)"},{"location":"yocto-project/rocko/","text":"Yocto Project 2.4 (Rocko) \u00b6 In the version of Yocto Project 2.4 (Rocko) the following machines are supported: Commercial name Machine Layer Beaglebone Black beaglebone meta-updatehub-ti Boundary Devices Nitrogen6X nitrogen6x meta-updatehub-freescale Element14 WaRP i.MX7 Solo imx7s-warp meta-updatehub-freescale NXP i.MX6 SABRE Automotive Board imx6qdlsabreauto meta-updatehub-freescale NXP i.MX6 SABRE Platform for Smart Devices imx6qdlsabresd meta-updatehub-freescale Raspberry Pi 3 Model B and B+ raspberrypi3 meta-updatehub-raspberrypi TechNexion PICO i.MX7 imx7d-pico meta-updatehub-freescale Toradex Apalis iMX6 apalis-imx6 meta-updatehub-freescale Wandboard Solo/Dual/Quad wandboard meta-updatehub-freescale","title":"Rocko"},{"location":"yocto-project/rocko/#yocto-project-24-rocko","text":"In the version of Yocto Project 2.4 (Rocko) the following machines are supported: Commercial name Machine Layer Beaglebone Black beaglebone meta-updatehub-ti Boundary Devices Nitrogen6X nitrogen6x meta-updatehub-freescale Element14 WaRP i.MX7 Solo imx7s-warp meta-updatehub-freescale NXP i.MX6 SABRE Automotive Board imx6qdlsabreauto meta-updatehub-freescale NXP i.MX6 SABRE Platform for Smart Devices imx6qdlsabresd meta-updatehub-freescale Raspberry Pi 3 Model B and B+ raspberrypi3 meta-updatehub-raspberrypi TechNexion PICO i.MX7 imx7d-pico meta-updatehub-freescale Toradex Apalis iMX6 apalis-imx6 meta-updatehub-freescale Wandboard Solo/Dual/Quad wandboard meta-updatehub-freescale","title":"Yocto Project 2.4 (Rocko)"},{"location":"yocto-project/sumo/","text":"Yocto Project 2.5 (Sumo) \u00b6 In the version of Yocto Project 2.5 (Sumo) the following machines are supported: Commercial name Machine Layer Beaglebone Black beaglebone meta-updatehub-ti Boundary Devices Nitrogen6X nitrogen6x meta-updatehub-freescale Element14 WaRP i.MX7 Solo imx7s-warp meta-updatehub-freescale NXP i.MX6 SABRE Automotive Board imx6qdlsabreauto meta-updatehub-freescale NXP i.MX6 SABRE Platform for Smart Devices imx6qdlsabresd meta-updatehub-freescale Raspberry Pi 3 Model B and B+ raspberrypi3 meta-updatehub-raspberrypi TechNexion PICO i.MX7 imx7d-pico meta-updatehub-freescale Toradex Apalis iMX6 apalis-imx6 meta-updatehub-freescale Wandboard Solo/Dual/Quad wandboard meta-updatehub-freescale","title":"Sumo"},{"location":"yocto-project/sumo/#yocto-project-25-sumo","text":"In the version of Yocto Project 2.5 (Sumo) the following machines are supported: Commercial name Machine Layer Beaglebone Black beaglebone meta-updatehub-ti Boundary Devices Nitrogen6X nitrogen6x meta-updatehub-freescale Element14 WaRP i.MX7 Solo imx7s-warp meta-updatehub-freescale NXP i.MX6 SABRE Automotive Board imx6qdlsabreauto meta-updatehub-freescale NXP i.MX6 SABRE Platform for Smart Devices imx6qdlsabresd meta-updatehub-freescale Raspberry Pi 3 Model B and B+ raspberrypi3 meta-updatehub-raspberrypi TechNexion PICO i.MX7 imx7d-pico meta-updatehub-freescale Toradex Apalis iMX6 apalis-imx6 meta-updatehub-freescale Wandboard Solo/Dual/Quad wandboard meta-updatehub-freescale","title":"Yocto Project 2.5 (Sumo)"},{"location":"yocto-project/supported-machines/","text":"The UpdateHub support multiple Yocto Project releases and the latest Yocto Project release we offer support for is the 3.3 (Hardknott), including the 3.1 (Dunfell) LTS release. If you need to use an Yocto Project release different than the 3.3 (Hardknott) release please refer to the respective layers to check for compatibility. Manufacturer Repository Freescale https://github.com/UpdateHub/meta-updatehub-freescale.git RaspberryPi https://github.com/UpdateHub/meta-updatehub-raspberrypi.git Texas Intruments https://github.com/UpdateHub/meta-updatehub-ti.git UpdateHub has support for the machines specified in the table below. Remember that it is possible for other configurations to work correctly with UpdateHub, the machines that have been configured and tested are the ones informed here. Bellow the machines with support to Yocto Project 3.3 (Hardknott): Commercial name Machine Layer Beaglebone Black beaglebone meta-updatehub-ti Boundary Devices Nitrogen6X nitrogen6x meta-updatehub-freescale NXP i.MX6 SABRE Automotive Board imx6qdlsabreauto meta-updatehub-freescale NXP i.MX6 SABRE Platform for Smart Devices imx6qdlsabresd meta-updatehub-freescale Raspberry Pi 0 raspberrypi0 meta-updatehub-raspberrypi Raspberry Pi 3 Model B and B+ raspberrypi3 meta-updatehub-raspberrypi Raspberry Pi 4 Model B raspberrypi4 meta-updatehub-raspberrypi TechNexion PICO i.MX7 imx7d-pico meta-updatehub-freescale Toradex Apalis iMX6 apalis-imx6 meta-updatehub-freescale Toradex Colibri iMX6 colibri-imx6 meta-updatehub-freescale Toradex Colibri iMX7 (with eMMC storage) colibri-imx7-emmc meta-updatehub-freescale Wandboard Solo/Dual/Quad wandboard meta-updatehub-freescale In the version of Yocto Project 3.1 LTS (Dunfell) the following machines are supported: Commercial name Machine Layer Beaglebone Black beaglebone meta-updatehub-ti Boundary Devices Nitrogen6X nitrogen6x meta-updatehub-freescale NXP i.MX6 SABRE Automotive Board imx6qdlsabreauto meta-updatehub-freescale NXP i.MX6 SABRE Platform for Smart Devices imx6qdlsabresd meta-updatehub-freescale Raspberry Pi 0 raspberrypi0 meta-updatehub-raspberrypi Raspberry Pi 3 Model B and B+ raspberrypi3 meta-updatehub-raspberrypi Raspberry Pi 4 Model B raspberrypi4 meta-updatehub-raspberrypi TechNexion PICO i.MX7 imx7d-pico meta-updatehub-freescale Toradex Apalis iMX6 apalis-imx6 meta-updatehub-freescale Toradex Colibri iMX6 colibri-imx6 meta-updatehub-freescale Toradex Colibri iMX7 eMMC colibri-imx7-emmc meta-updatehub-freescale Wandboard Solo/Dual/Quad wandboard meta-updatehub-freescale The Updatehub has supported the Yocto Project since version 2.1 (Krogoth). In case you are using an older version of the Yocto Project, below you can find the supported versions and the respective machines: Yocto Project 3.2 (Gatesgarth) Yocto Project 3.0 (Zeus) Yocto Project 2.7 (Warrior) Yocto Project 2.6 (Thud) Yocto Project 2.5 (Sumo) Yocto Project 2.4 (Rocko) Yocto Project 2.3 (Pyro) Yocto Project 2.2 (Morty) Yocto Project 2.1 (Krogoth) If you have any difficulties or doubts, access the Gitter so we can help you.","title":"Supported machines"},{"location":"yocto-project/thud/","text":"Yocto Project 2.6 (Thud) \u00b6 In the version of Yocto Project 2.6 (Thud) the following machines are supported: Commercial name Machine Layer Beaglebone Black beaglebone meta-updatehub-ti Boundary Devices Nitrogen6X nitrogen6x meta-updatehub-freescale Element14 WaRP i.MX7 Solo imx7s-warp meta-updatehub-freescale NXP i.MX6 SABRE Automotive Board imx6qdlsabreauto meta-updatehub-freescale NXP i.MX6 SABRE Platform for Smart Devices imx6qdlsabresd meta-updatehub-freescale Raspberry Pi 3 Model B and B+ raspberrypi3 meta-updatehub-raspberrypi TechNexion PICO i.MX7 imx7d-pico meta-updatehub-freescale Toradex Apalis iMX6 apalis-imx6 meta-updatehub-freescale Toradex Colibri iMX6 colibri-imx6 meta-updatehub-freescale Wandboard Solo/Dual/Quad wandboard meta-updatehub-freescale","title":"Thud"},{"location":"yocto-project/thud/#yocto-project-26-thud","text":"In the version of Yocto Project 2.6 (Thud) the following machines are supported: Commercial name Machine Layer Beaglebone Black beaglebone meta-updatehub-ti Boundary Devices Nitrogen6X nitrogen6x meta-updatehub-freescale Element14 WaRP i.MX7 Solo imx7s-warp meta-updatehub-freescale NXP i.MX6 SABRE Automotive Board imx6qdlsabreauto meta-updatehub-freescale NXP i.MX6 SABRE Platform for Smart Devices imx6qdlsabresd meta-updatehub-freescale Raspberry Pi 3 Model B and B+ raspberrypi3 meta-updatehub-raspberrypi TechNexion PICO i.MX7 imx7d-pico meta-updatehub-freescale Toradex Apalis iMX6 apalis-imx6 meta-updatehub-freescale Toradex Colibri iMX6 colibri-imx6 meta-updatehub-freescale Wandboard Solo/Dual/Quad wandboard meta-updatehub-freescale","title":"Yocto Project 2.6 (Thud)"},{"location":"yocto-project/warrior/","text":"Yocto Project 2.7 (Warrior) \u00b6 In the version of Yocto Project 2.7 (Warrior) the following machines are supported: Commercial name Machine Layer Beaglebone Black beaglebone meta-updatehub-ti Boundary Devices Nitrogen6X nitrogen6x meta-updatehub-freescale Element14 WaRP i.MX7 Solo imx7s-warp meta-updatehub-freescale NXP i.MX6 SABRE Automotive Board imx6qdlsabreauto meta-updatehub-freescale NXP i.MX6 SABRE Platform for Smart Devices imx6qdlsabresd meta-updatehub-freescale Raspberry Pi 3 Model B and B+ raspberrypi3 meta-updatehub-raspberrypi TechNexion PICO i.MX7 imx7d-pico meta-updatehub-freescale Toradex Apalis iMX6 apalis-imx6 meta-updatehub-freescale Toradex Colibri iMX6 colibri-imx6 meta-updatehub-freescale Wandboard Solo/Dual/Quad wandboard meta-updatehub-freescale","title":"Warrior"},{"location":"yocto-project/warrior/#yocto-project-27-warrior","text":"In the version of Yocto Project 2.7 (Warrior) the following machines are supported: Commercial name Machine Layer Beaglebone Black beaglebone meta-updatehub-ti Boundary Devices Nitrogen6X nitrogen6x meta-updatehub-freescale Element14 WaRP i.MX7 Solo imx7s-warp meta-updatehub-freescale NXP i.MX6 SABRE Automotive Board imx6qdlsabreauto meta-updatehub-freescale NXP i.MX6 SABRE Platform for Smart Devices imx6qdlsabresd meta-updatehub-freescale Raspberry Pi 3 Model B and B+ raspberrypi3 meta-updatehub-raspberrypi TechNexion PICO i.MX7 imx7d-pico meta-updatehub-freescale Toradex Apalis iMX6 apalis-imx6 meta-updatehub-freescale Toradex Colibri iMX6 colibri-imx6 meta-updatehub-freescale Wandboard Solo/Dual/Quad wandboard meta-updatehub-freescale","title":"Yocto Project 2.7 (Warrior)"},{"location":"yocto-project/yocto-project-guide/","text":"Yocto Project guide \u00b6 Here we have a guide with the necessary steps for adding UpdateHub , either in a project that already exists or in a new project. Each step provides a brief description of the process that must be performed and a link to a section with more detailed information about this process. Before you start, we ask you to check if your board is supported by UpdateHub . If your board still does not have support or you encounter difficulties we will be happy to assist you through our Gitter or contact us at contact@updatehub.io First step: adding layer \u00b6 Create project from scratch \u00b6 For the creation of a project that already has the necessary layers to support UpdateHub we recommend using the platform that will download and add the necessary layers automatically, allowing you to start your implementation quickly. Integrating onto a existing project \u00b6 In a finished or under development project, the way to integrate UpdateHub is done by adding layers directly . Second step: creating a product \u00b6 Create a Product is necessary for some variables such as the product identifier to be generated. These variables must be included in the image that will be generated so that the device has the necessary data to be authorized on the UpdateHub server when accessing it. To create a product you need to be logged into your UpdateHub Cloud account . Third step: requesting an Access Key \u00b6 Access key is a variable that Updatehub uses to guarantee the authenticity of a device when it requests access to the server. Generating an Access Key is easy and after just putting it in a project's settings before the image that will be loaded on the devices is generated. Just like creating a product, creating a access key takes place within the Dashboard Fourth step: configuring the variables \u00b6 Here we show how to setting up the UpdateHub variables necessary for the correct functioning of UpdateHub . Definitions of variables as well as other variables can be found in the Glossary of variables . Fifth step: in your board \u00b6 After adding the necessary layers and configuring the variables now just generate the image with the bitbake command, save the image on the target devices and that's it! Sixth step: sending a package to server \u00b6 When changes occur in the original image that is present in devices in the field, it is necessary to update these devices by sending the package with the changed image to the UpdateHub server for it to be applied. Congratulations! Your UpdateHub support is up and running. Can't run a tutorial step? Please contact us at Gitter so we can help you.","title":"Yocto Project guide"},{"location":"yocto-project/yocto-project-guide/#yocto-project-guide","text":"Here we have a guide with the necessary steps for adding UpdateHub , either in a project that already exists or in a new project. Each step provides a brief description of the process that must be performed and a link to a section with more detailed information about this process. Before you start, we ask you to check if your board is supported by UpdateHub . If your board still does not have support or you encounter difficulties we will be happy to assist you through our Gitter or contact us at contact@updatehub.io","title":"Yocto Project guide"},{"location":"yocto-project/yocto-project-guide/#first-step-adding-layer","text":"","title":"First step: adding layer"},{"location":"yocto-project/yocto-project-guide/#create-project-from-scratch","text":"For the creation of a project that already has the necessary layers to support UpdateHub we recommend using the platform that will download and add the necessary layers automatically, allowing you to start your implementation quickly.","title":"Create project from scratch"},{"location":"yocto-project/yocto-project-guide/#integrating-onto-a-existing-project","text":"In a finished or under development project, the way to integrate UpdateHub is done by adding layers directly .","title":"Integrating onto a existing project"},{"location":"yocto-project/yocto-project-guide/#second-step-creating-a-product","text":"Create a Product is necessary for some variables such as the product identifier to be generated. These variables must be included in the image that will be generated so that the device has the necessary data to be authorized on the UpdateHub server when accessing it. To create a product you need to be logged into your UpdateHub Cloud account .","title":"Second step: creating a product"},{"location":"yocto-project/yocto-project-guide/#third-step-requesting-an-access-key","text":"Access key is a variable that Updatehub uses to guarantee the authenticity of a device when it requests access to the server. Generating an Access Key is easy and after just putting it in a project's settings before the image that will be loaded on the devices is generated. Just like creating a product, creating a access key takes place within the Dashboard","title":"Third step: requesting an Access Key"},{"location":"yocto-project/yocto-project-guide/#fourth-step-configuring-the-variables","text":"Here we show how to setting up the UpdateHub variables necessary for the correct functioning of UpdateHub . Definitions of variables as well as other variables can be found in the Glossary of variables .","title":"Fourth step: configuring the variables"},{"location":"yocto-project/yocto-project-guide/#fifth-step-in-your-board","text":"After adding the necessary layers and configuring the variables now just generate the image with the bitbake command, save the image on the target devices and that's it!","title":"Fifth step: in your board"},{"location":"yocto-project/yocto-project-guide/#sixth-step-sending-a-package-to-server","text":"When changes occur in the original image that is present in devices in the field, it is necessary to update these devices by sending the package with the changed image to the UpdateHub server for it to be applied. Congratulations! Your UpdateHub support is up and running. Can't run a tutorial step? Please contact us at Gitter so we can help you.","title":"Sixth step: sending a package to server"},{"location":"yocto-project/yocto-project-reference/","text":"Yocto Project reference \u00b6 In this section we cover the topics that involve UpdateHub with Yocto Project such as adding UpdateHub layers, setting variables, access keys and glossary. review Supported version \u00b6 The UpdateHub offers a high quality integration for the Yocto Project and provides a ready to use support for a number of boards ( RaspberryPi , Texas Instruments e Freescale ). Every six months, a new version of Yocto Project is released. The current version is the Yocto Project 3.0, codename Zeus , and its support is provided by the meta-updatehub layer. This layer provides all the infrastructure code to enable the use of Yocto Project together with the UpdateHub . The minimal set of layers to use the UpdateHub are: Layer name Branch name poky zeus meta-openembedded/meta-oe zeus meta-openembedded/meta-python zeus meta-updatehub zeus Besides the basic support, there are many boards with UpdateHub support, provided by extra BSP integration layers, as shown at the table below: Board full name BSP layer name Machine name Branch name BeagleBone Black meta-updatehub-ti beaglebone zeus Raspberry Pi 3 meta-updatehub-raspberrypi raspberrypi3 zeus NXP i.MX6QP/Q/DL SABRE Smart Device meta-updatehub-freescale imx6qdlsabresd zeus Boundary Devices Nitrogen6X meta-updatehub-freescale nitrogen6x zeus Boundary Devices i.MX6 SABRELite meta-updatehub-freescale nitrogen6x zeus TechNexion i.MX7 PICO meta-updatehub-freescale imx7d-pico zeus Toradex Apalis iMX6Q/D meta-updatehub-freescale apalis-imx6 zeus WaRP7 meta-updatehub-freescale imx7s-warp zeus Wandboard i.MX6 QuadPlus/Quad/Dual/Solo meta-updatehub-freescale wandboard zeus If you need to use an earlier Yocto Project version, the UpdateHub is also supported. Currently, there is support for following previous Yocto Project versions: Yocto Project 2.1, codename Krogoth Yocto Project 2.2, codename Morty Yocto Project 2.3, codename Pyro Yocto Project 2.4, codename Rocko Yocto Project 2.5, codename Sumo Yocto Project 2.6, codename Thud Yocto Project 2.7, codename Warrior Yocto Project 3.0, codename Zeus These earlier versions are actively supported by the UpdateHub , but features and compatible machines may vary among them. Adding layer to your project \u00b6 The first step is initialize the environment to build a Linux image using Yocto Project . To start working with Yocto Project we need to fetch all the needed layers, that includes the poky , meta-openembedded , meta-raspberrypi , meta-updatehub and meta-updatehub-raspberrypi layers. The meta-updatehub is the layer that adds support to UpdateHub itself, and meta-updatehub-raspberrypi includes UpdateHub support for Raspberry Pi machines. In addition, we need to get the meta-openembedded layer, because UpdateHub has some dependencies, such as Python 3 packages to create the uhu utility used as UpdateHub package manager and will be covered in this guide. Here we will show you two different approaches to download the necessary layers to support UpdateHub : one using a platform which will download the necessary layers and add them automatically to the project, the other approach is to manually download and add these layers. Using UpdateHub Platform \u00b6 To get a platform you need have Repo installed. Repo is a tool that helps manage many Git repositories, uploading to revision control systems and automating parts of the development workflow. Install the repo utility: mkdir ~/bin curl http://commondatastorage.googleapis.com/git-repo-downloads/repo > ~/bin/repo chmod a+x ~/bin/repo Download the platform source: PATH=${PATH}:~/bin mkdir updatehub-platform cd updatehub-platform repo init -u https://github.com/UpdateHub/updatehub-yocto-project-reference-platform.git -b zeus repo sync Setup the environment: source ./setup-environment build At the end of the commands you have every metadata you need to start working. Adding the layers manually \u00b6 To include the Updatehub Yocto layers in your build is easy just clone the meta-updatehub layer and the machine support layer to your sources directory following the commands below: git clone https://github.com/openembedded/meta-openembedded -b zeus git clone https://github.com/UpdateHub/meta-updatehub -b zeus In /build folder of your project include: bitbake-layers add-layer ../meta-openembedded/meta-oe bitbake-layers add-layer ../meta-openembedded/meta-python bitbake-layers add-layer ../meta-openembedded/meta-networking bitbake-layers add-layer ../meta-updatehub For Raspberry Pi 3, you can do that using: git clone https://github.com/UpdateHub/meta-updatehub-raspberrypi In /build folder of your project include: bitbake-layers add-layer ../meta-updatehub-raspberrypi/ For BeagleBone Black , you can use: git clone https://github.com/UpdateHub/meta-updatehub-ti In /build folder of your project include: bitbake-layers add-layer ../meta-updatehub-ti/ And for imx6qdlsabresd , use: git clone https://github.com/UpdateHub/meta-updatehub-freescale In /build folder of your project include: bitbake-layers add-layer ../meta-updatehub-freescale/ Done! Now you have the UpdateHub layer in your project. Configurating UpdateHub variables \u00b6 You should now to include UpdateHub system variables in conf/local.conf . The variables below are the basics for the correct configuration. More details and options see Glossary of variables . UPDATEHUB_PRODUCT_UID - identifies the product id in use and this is used by rollouts. It is generate in create process ends or you get this code in UpdateHub Dashboard, in Product page. UPDATEHUB_ACCESS_ID and UPDATEHUB_ACCESS_SECRET - They can be generate in Settings available in right top of screen and are necessary for server connection. UPDATEHUB_PACKAGE_VERSION_SUFFIX - added optionally, is advised for version organization. Finally the final of your local.conf file should seem like this. UPDATEHUB_PRODUCT_UID = \"05344b71c3e9f8...\" UPDATEHUB_ACCESS_ID = \"your-email@gmail.com-8bc21121049af...\" UPDATEHUB_ACCESS_SECRET = \"9b1fcee96795fa5dea5cd04cb1d2...\" UPDATEHUB_PACKAGE_VERSION_SUFFIX = \"-test-image-1.0\" Cases of adding layers manually \u00b6 If you have used the platform, the process below is not necessary, because the platform already has updatehub-image class configured. In case you are not using the platform, in addition to the variable configuration specified above, you will need to add update-image class of UpdateHub in your project recipe for to use the setting available. For this you must include \"inherit updatehub-image\" in myproject/../my-image.bb or just to add \"updatehub-image\" in inherit if this exists. The your new image with UpdateHub support layer is ready. RSA Key \u00b6 RSA keys are asymmetric encryption keys that serve to provide greater security in communications. The UpdateHub verifies the authenticity of every Package update prior applying it. To do so, it uses a RSA key that to check if the Package has not been modified or corrupted by any means. Each device will contain the public key, public_key.pem , included on the device image, which will validate any received Package before unpacking, which must have been signed with the private key, private_key.pem , when generating the update package. Although these keys are not mandatory on UpdateHub, we advise their use as an additional data protection mechanism. In this session we will cover: Generating a RSA Key Setting up RSA Key Generating a RSA Key \u00b6 The generation of the RSA keys requires the openssl utility. The private RSA key is generated using the command below: mkdir -p ~/updatehub-keys openssl genpkey -algorithm RSA -out ~/updatehub-keys/private_key.pem -pkeyopt rsa_keygen_bits:4096 Next we need to extract the public RSA key from the private key. Use the following command: openssl rsa -pubout -in ~/updatehub-keys/private_key.pem -out ~/updatehub-keys/public_key.pem Setting up RSA Key \u00b6 The keys need to be enabled inside your Yocto Project build configuration, so UpdateHub can deploy the public key inside the generated image and use the private key to sign the update package. You must set the UPDATEHUB_UHUPKG_PRIVATE_KEY and UPDATEHUB_UHUPKG_PRIVATE_KEY variables inside your conf/local.conf file as seen next: UPDATEHUB_UHUPKG_PRIVATE_KEY = \"~/updatehub-keys/private_key.pem\" UPDATEHUB_UHUPKG_PUBLIC_KEY = \"~/updatehub-keys/public_key.pem\" Keep save your RSA keys Once a device is deployed using a RSA key, the same key is used to validate every update package send to this device. It is important to keep the RSA keys safe or you'll not be able to send updates for those devices. Pushing an update package \u00b6 The UpdateHub works with upkg format for update package, and this is generated by the uhu . Update Utilities or uhu is an interactive prompt and a command line utility to manage update packages for UpdateHub agent and will provide you few new BitBake tasks, like this: uhupush : sends the update package to the UpdateHub Cloud. The generation of an update package is very simple. After the integration of the UpdateHub with your Yocto Project build is complete, the Bitbake tool can be used to generate and upload the update package. The following command does all the needed work in order to push the packages to the UpdateHub Cloud: bitbake <image> -c uhupush After running this, the UpdateHub Cloud will display that there is a new Package to update the Devices and you may start a Rollout through the interface. For more details or uhu install access UpdateHub Utilities .","title":"Yocto Project reference"},{"location":"yocto-project/yocto-project-reference/#yocto-project-reference","text":"In this section we cover the topics that involve UpdateHub with Yocto Project such as adding UpdateHub layers, setting variables, access keys and glossary. review","title":"Yocto Project reference"},{"location":"yocto-project/yocto-project-reference/#supported-version","text":"The UpdateHub offers a high quality integration for the Yocto Project and provides a ready to use support for a number of boards ( RaspberryPi , Texas Instruments e Freescale ). Every six months, a new version of Yocto Project is released. The current version is the Yocto Project 3.0, codename Zeus , and its support is provided by the meta-updatehub layer. This layer provides all the infrastructure code to enable the use of Yocto Project together with the UpdateHub . The minimal set of layers to use the UpdateHub are: Layer name Branch name poky zeus meta-openembedded/meta-oe zeus meta-openembedded/meta-python zeus meta-updatehub zeus Besides the basic support, there are many boards with UpdateHub support, provided by extra BSP integration layers, as shown at the table below: Board full name BSP layer name Machine name Branch name BeagleBone Black meta-updatehub-ti beaglebone zeus Raspberry Pi 3 meta-updatehub-raspberrypi raspberrypi3 zeus NXP i.MX6QP/Q/DL SABRE Smart Device meta-updatehub-freescale imx6qdlsabresd zeus Boundary Devices Nitrogen6X meta-updatehub-freescale nitrogen6x zeus Boundary Devices i.MX6 SABRELite meta-updatehub-freescale nitrogen6x zeus TechNexion i.MX7 PICO meta-updatehub-freescale imx7d-pico zeus Toradex Apalis iMX6Q/D meta-updatehub-freescale apalis-imx6 zeus WaRP7 meta-updatehub-freescale imx7s-warp zeus Wandboard i.MX6 QuadPlus/Quad/Dual/Solo meta-updatehub-freescale wandboard zeus If you need to use an earlier Yocto Project version, the UpdateHub is also supported. Currently, there is support for following previous Yocto Project versions: Yocto Project 2.1, codename Krogoth Yocto Project 2.2, codename Morty Yocto Project 2.3, codename Pyro Yocto Project 2.4, codename Rocko Yocto Project 2.5, codename Sumo Yocto Project 2.6, codename Thud Yocto Project 2.7, codename Warrior Yocto Project 3.0, codename Zeus These earlier versions are actively supported by the UpdateHub , but features and compatible machines may vary among them.","title":"Supported version"},{"location":"yocto-project/yocto-project-reference/#adding-layer-to-your-project","text":"The first step is initialize the environment to build a Linux image using Yocto Project . To start working with Yocto Project we need to fetch all the needed layers, that includes the poky , meta-openembedded , meta-raspberrypi , meta-updatehub and meta-updatehub-raspberrypi layers. The meta-updatehub is the layer that adds support to UpdateHub itself, and meta-updatehub-raspberrypi includes UpdateHub support for Raspberry Pi machines. In addition, we need to get the meta-openembedded layer, because UpdateHub has some dependencies, such as Python 3 packages to create the uhu utility used as UpdateHub package manager and will be covered in this guide. Here we will show you two different approaches to download the necessary layers to support UpdateHub : one using a platform which will download the necessary layers and add them automatically to the project, the other approach is to manually download and add these layers.","title":"Adding layer to your project"},{"location":"yocto-project/yocto-project-reference/#using-updatehub-platform","text":"To get a platform you need have Repo installed. Repo is a tool that helps manage many Git repositories, uploading to revision control systems and automating parts of the development workflow. Install the repo utility: mkdir ~/bin curl http://commondatastorage.googleapis.com/git-repo-downloads/repo > ~/bin/repo chmod a+x ~/bin/repo Download the platform source: PATH=${PATH}:~/bin mkdir updatehub-platform cd updatehub-platform repo init -u https://github.com/UpdateHub/updatehub-yocto-project-reference-platform.git -b zeus repo sync Setup the environment: source ./setup-environment build At the end of the commands you have every metadata you need to start working.","title":"Using UpdateHub Platform"},{"location":"yocto-project/yocto-project-reference/#adding-the-layers-manually","text":"To include the Updatehub Yocto layers in your build is easy just clone the meta-updatehub layer and the machine support layer to your sources directory following the commands below: git clone https://github.com/openembedded/meta-openembedded -b zeus git clone https://github.com/UpdateHub/meta-updatehub -b zeus In /build folder of your project include: bitbake-layers add-layer ../meta-openembedded/meta-oe bitbake-layers add-layer ../meta-openembedded/meta-python bitbake-layers add-layer ../meta-openembedded/meta-networking bitbake-layers add-layer ../meta-updatehub For Raspberry Pi 3, you can do that using: git clone https://github.com/UpdateHub/meta-updatehub-raspberrypi In /build folder of your project include: bitbake-layers add-layer ../meta-updatehub-raspberrypi/ For BeagleBone Black , you can use: git clone https://github.com/UpdateHub/meta-updatehub-ti In /build folder of your project include: bitbake-layers add-layer ../meta-updatehub-ti/ And for imx6qdlsabresd , use: git clone https://github.com/UpdateHub/meta-updatehub-freescale In /build folder of your project include: bitbake-layers add-layer ../meta-updatehub-freescale/ Done! Now you have the UpdateHub layer in your project.","title":"Adding the layers manually"},{"location":"yocto-project/yocto-project-reference/#configurating-updatehub-variables","text":"You should now to include UpdateHub system variables in conf/local.conf . The variables below are the basics for the correct configuration. More details and options see Glossary of variables . UPDATEHUB_PRODUCT_UID - identifies the product id in use and this is used by rollouts. It is generate in create process ends or you get this code in UpdateHub Dashboard, in Product page. UPDATEHUB_ACCESS_ID and UPDATEHUB_ACCESS_SECRET - They can be generate in Settings available in right top of screen and are necessary for server connection. UPDATEHUB_PACKAGE_VERSION_SUFFIX - added optionally, is advised for version organization. Finally the final of your local.conf file should seem like this. UPDATEHUB_PRODUCT_UID = \"05344b71c3e9f8...\" UPDATEHUB_ACCESS_ID = \"your-email@gmail.com-8bc21121049af...\" UPDATEHUB_ACCESS_SECRET = \"9b1fcee96795fa5dea5cd04cb1d2...\" UPDATEHUB_PACKAGE_VERSION_SUFFIX = \"-test-image-1.0\"","title":"Configurating UpdateHub variables"},{"location":"yocto-project/yocto-project-reference/#cases-of-adding-layers-manually","text":"If you have used the platform, the process below is not necessary, because the platform already has updatehub-image class configured. In case you are not using the platform, in addition to the variable configuration specified above, you will need to add update-image class of UpdateHub in your project recipe for to use the setting available. For this you must include \"inherit updatehub-image\" in myproject/../my-image.bb or just to add \"updatehub-image\" in inherit if this exists. The your new image with UpdateHub support layer is ready.","title":"Cases of adding layers manually"},{"location":"yocto-project/yocto-project-reference/#rsa-key","text":"RSA keys are asymmetric encryption keys that serve to provide greater security in communications. The UpdateHub verifies the authenticity of every Package update prior applying it. To do so, it uses a RSA key that to check if the Package has not been modified or corrupted by any means. Each device will contain the public key, public_key.pem , included on the device image, which will validate any received Package before unpacking, which must have been signed with the private key, private_key.pem , when generating the update package. Although these keys are not mandatory on UpdateHub, we advise their use as an additional data protection mechanism. In this session we will cover: Generating a RSA Key Setting up RSA Key","title":"RSA Key"},{"location":"yocto-project/yocto-project-reference/#generating-a-rsa-key","text":"The generation of the RSA keys requires the openssl utility. The private RSA key is generated using the command below: mkdir -p ~/updatehub-keys openssl genpkey -algorithm RSA -out ~/updatehub-keys/private_key.pem -pkeyopt rsa_keygen_bits:4096 Next we need to extract the public RSA key from the private key. Use the following command: openssl rsa -pubout -in ~/updatehub-keys/private_key.pem -out ~/updatehub-keys/public_key.pem","title":"Generating a RSA Key"},{"location":"yocto-project/yocto-project-reference/#setting-up-rsa-key","text":"The keys need to be enabled inside your Yocto Project build configuration, so UpdateHub can deploy the public key inside the generated image and use the private key to sign the update package. You must set the UPDATEHUB_UHUPKG_PRIVATE_KEY and UPDATEHUB_UHUPKG_PRIVATE_KEY variables inside your conf/local.conf file as seen next: UPDATEHUB_UHUPKG_PRIVATE_KEY = \"~/updatehub-keys/private_key.pem\" UPDATEHUB_UHUPKG_PUBLIC_KEY = \"~/updatehub-keys/public_key.pem\" Keep save your RSA keys Once a device is deployed using a RSA key, the same key is used to validate every update package send to this device. It is important to keep the RSA keys safe or you'll not be able to send updates for those devices.","title":"Setting up RSA Key"},{"location":"yocto-project/yocto-project-reference/#pushing-an-update-package","text":"The UpdateHub works with upkg format for update package, and this is generated by the uhu . Update Utilities or uhu is an interactive prompt and a command line utility to manage update packages for UpdateHub agent and will provide you few new BitBake tasks, like this: uhupush : sends the update package to the UpdateHub Cloud. The generation of an update package is very simple. After the integration of the UpdateHub with your Yocto Project build is complete, the Bitbake tool can be used to generate and upload the update package. The following command does all the needed work in order to push the packages to the UpdateHub Cloud: bitbake <image> -c uhupush After running this, the UpdateHub Cloud will display that there is a new Package to update the Devices and you may start a Rollout through the interface. For more details or uhu install access UpdateHub Utilities .","title":"Pushing an update package"},{"location":"yocto-project/zeus/","text":"Yocto Project 3.0 (Zeus) \u00b6 In the version of Yocto Project 3.0 (Zeus) the following machines are supported: Commercial name Machine Layer Beaglebone Black beaglebone meta-updatehub-ti Boundary Devices Nitrogen6X nitrogen6x meta-updatehub-freescale Element14 WaRP i.MX7 Solo imx7s-warp meta-updatehub-freescale NXP i.MX6 SABRE Automotive Board imx6qdlsabreauto meta-updatehub-freescale NXP i.MX6 SABRE Platform for Smart Devices imx6qdlsabresd meta-updatehub-freescale Raspberry Pi 3 Model B and B+ raspberrypi3 meta-updatehub-raspberrypi Raspberry Pi 4 Model B raspberrypi4 meta-updatehub-raspberrypi TechNexion PICO i.MX7 imx7d-pico meta-updatehub-freescale Toradex Apalis iMX6 apalis-imx6 meta-updatehub-freescale Toradex Colibri iMX6 colibri-imx6 meta-updatehub-freescale Wandboard Solo/Dual/Quad wandboard meta-updatehub-freescale","title":"Zeus"},{"location":"yocto-project/zeus/#yocto-project-30-zeus","text":"In the version of Yocto Project 3.0 (Zeus) the following machines are supported: Commercial name Machine Layer Beaglebone Black beaglebone meta-updatehub-ti Boundary Devices Nitrogen6X nitrogen6x meta-updatehub-freescale Element14 WaRP i.MX7 Solo imx7s-warp meta-updatehub-freescale NXP i.MX6 SABRE Automotive Board imx6qdlsabreauto meta-updatehub-freescale NXP i.MX6 SABRE Platform for Smart Devices imx6qdlsabresd meta-updatehub-freescale Raspberry Pi 3 Model B and B+ raspberrypi3 meta-updatehub-raspberrypi Raspberry Pi 4 Model B raspberrypi4 meta-updatehub-raspberrypi TechNexion PICO i.MX7 imx7d-pico meta-updatehub-freescale Toradex Apalis iMX6 apalis-imx6 meta-updatehub-freescale Toradex Colibri iMX6 colibri-imx6 meta-updatehub-freescale Wandboard Solo/Dual/Quad wandboard meta-updatehub-freescale","title":"Yocto Project 3.0 (Zeus)"},{"location":"zephyr-project/zephyr-project-guide/","text":"Zephyr Project guide \u00b6 UpdateHub agent for Zephyr makes it simple to remotely update all your embedded devices. It handles all aspects related to sending Firmware Over-the-Air (FOTA) updates with maximum security and efficiency, while you focus on adding value to your product. The UpdateHub Zephyr Agent can works on two modes: polling and manual update. Polling mode runs automatically on a predefined period, probing the server for updates and installing them without requiring user intervention. Manual mode requires the user to call the server probe and then, if there is an available update, also requires the user to decide if it is appropriate to update now or later. The UpdateHub Zephyr Demo uses Zephyr network management callbacks to know when the agent should start, see sample source code . Caveats \u00b6 The Zephyr port of UpdateHub was initialy developed to run on a Freedom-K64F kit using the ethernet connectivity. The application should build and run for other platforms with same connectivity. The sample provides overlay files to enable other tecnologies like WIFI, modem, BLE IPSP, 802.15.4 or OpenThread. These technologies depends on hardware resources and the correspondent overlay was designed to be generic instead full optimized. It is important understand that some wireless technologies may require a gateway or some sort of border router. It is out of scope provide such configuration in details. The MCUboot bootloader is required for UpdateHub work properly. Before chose a platform to test, make sure that SoC and board have support to it. UpdateHub currently uses two slots to perform the upgrade. More information about Device Firmware Upgrade subsystem and MCUboot can be found in MCUboot . UpdateHub acts like a service on Zephyr. It is heavily dependent on Zephyr sub-systems and it uses CoAP over UDP. Building and Running \u00b6 Before start, make sure follow steps from Zephyr Getting Started Guide . The below steps describe how to build and run the UpdateHub sample in Zephyr. Open a terminal terminal 1 and navigate to your Zephyr project directory. This allows contruct and run everything from a common place. ls bootloader modules tools zephyr Step 1: Build/Flash MCUboot \u00b6 The MCUboot can be build following the instructions in the MCUboot documentation page. Flash the resulting image file using west on terminal 1 . # From the root of the zephyr repository west build -b frdm_k64f -d build/mcuboot-frdm_k64f bootloader/mcuboot/boot/zephyr west flash -d build/mcuboot-frdm_k64f Step 2: Start the UpdateHub Server \u00b6 Step 2.1: UpdateHub-CE (Community Edition) \u00b6 The Zephyr sample application is configured by default to use the UpdateHub-CE server edition. This version implies you need run your own server. The UpdateHub-CE is distributed as a docker container and can be on your local network or even instaled on a service provider like Digital Ocean, Vultr etc. To start using the UpdateHub-CE simple execute the docker command with the following parameters on another terminal terminal 2 . docker run -it -p 8080:8080 -p 5683:5683/udp --rm updatehub/updatehub-ce:latest Step 2.2: UpdateHub Cloud \u00b6 The UpdateHub Cloud is an enterprise-grade solution. It provides almost same resources than UpdateHub-CE with the DTLS as main diferential. For more details on how to use the UpdateHub Cloud please refer to the documentation on UpdateHub Cloud . The UpdateHub Cloud has the option to use CoAPS/DTLS or not. If you want to use the CoAPS/DTLS, simply add the overlay-dtls.conf when building the sample. You can use the provided certificate for test this example or create your own. The below procedure instruct how create a new certificate using openssl on a Linux machine on terminal terminal 2 . openssl genrsa -out privkey.pem 512 openssl req -new -x509 -key privkey.pem -out servercert.pem The servercert and privkey files must be embedded in the application by certificates.h file. The following procedure can be used to generated the required der files: openssl x509 -in servercert.pem -outform DER -out servercert.der openssl pkcs8 -topk8 -inform PEM -outform DER -nocrypt -in privkey.pem -out privkey.der The der files should be placed on the sample source at certificates directory. Note When using UpdateHub Cloud server it is necessary update your own overlay-prj.conf with option CONFIG_UPDATEHUB_CE equal n . Step 3: Configure UpdateHub Sample \u00b6 The updatehub have several Kconfig options that are necessary configure to make it work or tune communication. Set CONFIG_UPDATEHUB_CE select between UpdateHub edition. The y value will select UpdateHub-CE otherwise n selects UpdateHub Cloud. Set CONFIG_UPDATEHUB_SERVER with your local IP address that runs the UpdateHub-CE server edition. If your are using a service provider a DNS name is a valid option too. This option is only valid when using UpdateHub-CE. Set CONFIG_UPDATEHUB_POLL_INTERVAL with the polling period of your preference, remembering that the limit is between 0 and 43200 minutes (30 days). The default value is 1440 minutes (24h). Set CONFIG_UPDATEHUB_PRODUCT_UID with your product ID. When using UpdateHub-CE the valid is available at overlay-prj.conf.example file. Step 4: Build UpdateHub App \u00b6 In order to correctly build UpdateHub the overlay files must be use correctly. More information about overlay files in :ref: important-build-vars . Note It is out of scope at this moment provide support for experimental features. However, the configuration and use is similar to the start point indicated on the experimental network interface. Step 4.1: Build for Ethernet \u00b6 The ethernet depends only from base configuration. west build -b [ frdm_k64f | nucleo_f767zi ] \\ -d build/app zephyr/samples/subsys/mgmt/updatehub -- \\ -DOVERLAY_CONFIG=overlay-prj.conf Step 4.2: Build for WiFi \u00b6 For WiFi, it needs add overlay-wifi.conf . Here a shield provides WiFi connectivity using, for instance, arduino headers. See ESP-8266 Module for details. west build -b [ frdm_k64f | nrf52840dk_nrf52840 | nucleo_f767zi ] \\ -d build/app zephyr/samples/subsys/mgmt/updatehub -- \\ -DSHIELD=esp_8266_arduino \\ -DOVERLAY_CONFIG=\"overlay-wifi.conf;overlay-prj.conf\" Note The board disco_l475_iot1 is not supported. The es-WIFI driver currently doesn't support UDP. Step 4.3: Build for Modem \u00b6 Modem needs add overlay-modem.conf . Now, a DTC overlay file is used to configure the glue between the modem and an arduino headers. The modem config uses PPP over GSM modem, see Generic GSM Modem Sample . west build -b [ frdm_k64f | nrf52840dk_nrf52840 | nucleo_f767zi ] \\ -d build/app zephyr/samples/subsys/mgmt/updatehub -- \\ -DOVERLAY_CONFIG=\"overlay-modem.conf;overlay-prj.conf\" \\ -DDTC_OVERLAY_FILE=arduino.overlay Step 4.4: Build for IEEE 802.15.4 [experimental] \u00b6 For IEEE 802.15.4 needs add overlay-802154.conf . This requires two nodes: one will be the host and the second one will be the device under test. The validation needs a Linux kernel >= 4.9 with all 6loWPAN support. The start point is try reproduce the Zephyr wpanusb sample . It is out of scope at this moment provide support since it is experimental. The gateway was tested with both native linux driver and atusb and with wpanusb sample. west build -b nrf52840dk_nrf52840 \\ -d build/app zephyr/samples/subsys/mgmt/updatehub -- \\ -DOVERLAY_CONFIG=\"overlay-802154.conf;overlay-prj.conf\" west build -b [ frdm_k64f | nucleo_f767zi ] \\ -d build/app zephyr/samples/subsys/mgmt/updatehub -- \\ -DSHIELD=atmel_rf2xx_arduino \\ -DOVERLAY_CONFIG=\"overlay-802154.conf;overlay-prj.conf\" Step 4.5: Build for BLE IPSP [experimental] \u00b6 The BLE IPSP needs overlay-ipsp.conf . This may requires two nodes: one will be the host and the second one will be the device under test. The validation needs a Linux kernel >= 4.9 with all 6loWPAN support. In this particular case the Bluetooth 6LoWPAN module is needed. The start point is try reproduce the Zephyr Bluetooth: ipsp sample . It is out of scope at this moment provide support since it is experimental. The gateway was tested with native linux driver and an USB dongle. west build -b nrf52840dk_nrf52840 \\ -d build/app zephyr/samples/subsys/mgmt/updatehub -- \\ -DOVERLAY_CONFIG=\"overlay-ipsp.conf;overlay-prj.conf\" Step 4.6: Build for OpenThread Network [experimental] \u00b6 The OpenThread requries the overlay-ot.conf . It requires two nodes: one will be the host NCP and the second one will be the device under test. The validation needs a Linux kernel >= 4.9 with optional NAT-64 support. The start point is try reproduce the OpenThread Router . It is out of scope at this moment provide support since it is experimental. The gateway was tested using two boards with OpenThread 1.1.1 on NCP mode. west build -b nrf52840dk_nrf52840 \\ -d build/app zephyr/samples/subsys/mgmt/updatehub -- \\ -DOVERLAY_CONFIG=\"overlay-ot.conf;overlay-prj.conf\" Step 5: Sign the app image \u00b6 The app image is the application itself that will be on the board. This app will connect to UpdateHub server and check for new images. The image will be loaded on the board with version 1.0.0. It is important check what file format you SoC tools uses. In general, Zephyr can create images with binary ( .bin ) image format or Intel's ( .hex ) image format. The Zephyr provide the west tool that simplify the signing process. Just call west with proper parameter values: west sign -t imgtool -d build/app -- --version 1.0.0 --pad \\ --key bootloader/mcuboot/root-rsa-2048.pem === image configuration: partition offset: 131072 (0x20000) partition size: 393216 (0x60000) rom start offset: 512 (0x200) === signing binaries unsigned bin: <zephyrdir>/build/app/zephyr/zephyr.bin signed bin: <zephyrdir>/build/app/zephyr/zephyr.signed.bin Step 6: Flash the app image \u00b6 west flash -d build/app --bin-file build/app/zephyr/zephyr.signed.bin Note: Command variation to flash a hex file west flash -d build/app --hex-file build/app/zephyr/zephyr.signed.hex At this point you can access a third terminal terminal 3 to check if image is running. Open the terminal 3 and press reset on your board: minicom -D /dev/ttyACM0 Step 7: Signing the binary test image \u00b6 The test image needs different parameters to add the signature. Pay attention to make sure you are creating the right signed image. The test image will be created with version 2.0.0 in this tutorial: west sign --no-hex --bin -B build/zephyr-2.0.0.bin -t imgtool -d build/app -- \\ --version 2.0.0 --key bootloader/mcuboot/root-rsa-2048.pem === image configuration: partition offset: 131072 (0x20000) partition size: 393216 (0x60000) rom start offset: 512 (0x200) === signing binaries unsigned bin: <zephyrdir>/build/app/zephyr/zephyr.bin signed bin: build/zephyr-2.0.0.bin Step 8: Create a package with UpdateHub Utilities (uhu) \u00b6 First, install UpdateHub Utilities ( uhu ) on your system, using: pip3 install --user uhu After installing uhu you will need to set the product-uid . The value for UpdateHub-CE can be found at overlay-prj.conf.example file. For UpdateHub Cloud, you need copy the value from the web interface. uhu product use \"e4d37cfe6ec48a2d069cc0bbb8b078677e9a0d8df3a027c4d8ea131130c4265f\" Then, add the package and its mode ( zephyr ): uhu package add build/zephyr-2.0.0.bin -m zephyr Then inform what version this image is: uhu package version 2.0.0 And finally you can build the package by running: uhu package archive --output build/zephyr-2.0.0.pkg The remaining steps are dedicated to UpdateHub-CE. If you are using UpdateHub Cloud you can find the proper procedure at docs.updatehub.io _. Step 9: Add the package to server \u00b6 Step 9.1: UpdateHub-CE \u00b6 Add the package to the UpdateHub-CE server. Open your browser to the server URL, <your-ip-address>:8080 , and logging into the server using admin as the login and password by default. After logging in, click on the package menu, then UPLOAD PACKAGE , and select the package built in step 8. Step 9.2: UpdateHub Cloud \u00b6 UpdateHub Cloud allows manager packages only by API. To enable API access by terminal, add following three environment variables: export UHU_ACCESS_ID=\"<email address>-<id number>\" export UHU_ACCESS_SECRET=\"<your secret>\" export UHU_SERVER_URL=\"https://api.updatehub.io\" The last step is call package push to send package built in step 8 to UpdateHub cloud server. uhu package push Note This can be easilly integrated with a CI/CD development workflow Step 10: Register device on server \u00b6 If you chose Manual , register your device at updatehub server by using the terminal session where you are debugging the board terminal 3 . Type the following command: updatehub run If everything is alright, it will print on the screen No update available . For Polling mode, the system will automatically register your device after CONFIG_UPDATEHUB_POLL_INTERVAL minutes. The updatehub run can be used to speed-up. Note The message Could not receive data means that the application was not able to reached the updatehub server for some reason. The most common cases are server down, missing network routes and forget to change the content of overlay-prj.conf file. Step 11: Create a rollout \u00b6 In the browser where the UpdateHub-CE is open, click on menu Rollout and then CREATE ROLLOUT . Select the version of the package that you added in step 9. With that, the update is published, and the server is ready to accept update requests. Step 12: Run the update \u00b6 Back in the terminal session that you used for debugging the board, type the following command: updatehub run And then wait. The board will probe the server, check if there are any new updates, and then download the update package you've just created. If everything goes fine the message Image flashed successfully, you can reboot now will be printed on the terminal. If you are using the Polling mode the board will reboot automatically and Step 13 can be skipped. Step 13: Reboot the system \u00b6 In the terminal you used for debugging the board, type the following command: kernel reboot cold Your board will reboot and then start with the new image. After rebooting, the board will automatically ping the server again and the message No update available will be printed on the terminal. You can check the newer version using the following command: uart:~$ updatehub info Unique device id: acbdef0123456789 Firmware Version: 2.0.0 Product uid: e4d37cfe6ec48a2d069cc0bbb8b078677e9a0d8df3a027c4d8ea131130c4265f UpdateHub Server: <server ip/dns> uart:~$ Hardware \u00b6 The below list of hardware have been used by UpdateHub team. ID Network Interface Shield / Device 1 Ethernet Native 2 WIFI ESP-8266 3 MODEM (PPP) SIMCOM 808 4 IEEE 802.15.4 (6loWPAN) Native, RF2xx 5 BLE IPSP (6loWPAN) Native 6 OpenThread Network Native Board Network Interface ID NXP FRDM-K64F 1, 2, 3, 4 nRF52840 DK 2, 3, 4, 5, 6 ST Nucleo F767ZI 1, 2, 3, 4","title":"Zephyr Project guide"},{"location":"zephyr-project/zephyr-project-guide/#zephyr-project-guide","text":"UpdateHub agent for Zephyr makes it simple to remotely update all your embedded devices. It handles all aspects related to sending Firmware Over-the-Air (FOTA) updates with maximum security and efficiency, while you focus on adding value to your product. The UpdateHub Zephyr Agent can works on two modes: polling and manual update. Polling mode runs automatically on a predefined period, probing the server for updates and installing them without requiring user intervention. Manual mode requires the user to call the server probe and then, if there is an available update, also requires the user to decide if it is appropriate to update now or later. The UpdateHub Zephyr Demo uses Zephyr network management callbacks to know when the agent should start, see sample source code .","title":"Zephyr Project guide"},{"location":"zephyr-project/zephyr-project-guide/#caveats","text":"The Zephyr port of UpdateHub was initialy developed to run on a Freedom-K64F kit using the ethernet connectivity. The application should build and run for other platforms with same connectivity. The sample provides overlay files to enable other tecnologies like WIFI, modem, BLE IPSP, 802.15.4 or OpenThread. These technologies depends on hardware resources and the correspondent overlay was designed to be generic instead full optimized. It is important understand that some wireless technologies may require a gateway or some sort of border router. It is out of scope provide such configuration in details. The MCUboot bootloader is required for UpdateHub work properly. Before chose a platform to test, make sure that SoC and board have support to it. UpdateHub currently uses two slots to perform the upgrade. More information about Device Firmware Upgrade subsystem and MCUboot can be found in MCUboot . UpdateHub acts like a service on Zephyr. It is heavily dependent on Zephyr sub-systems and it uses CoAP over UDP.","title":"Caveats"},{"location":"zephyr-project/zephyr-project-guide/#building-and-running","text":"Before start, make sure follow steps from Zephyr Getting Started Guide . The below steps describe how to build and run the UpdateHub sample in Zephyr. Open a terminal terminal 1 and navigate to your Zephyr project directory. This allows contruct and run everything from a common place. ls bootloader modules tools zephyr","title":"Building and Running"},{"location":"zephyr-project/zephyr-project-guide/#step-1-buildflash-mcuboot","text":"The MCUboot can be build following the instructions in the MCUboot documentation page. Flash the resulting image file using west on terminal 1 . # From the root of the zephyr repository west build -b frdm_k64f -d build/mcuboot-frdm_k64f bootloader/mcuboot/boot/zephyr west flash -d build/mcuboot-frdm_k64f","title":"Step 1: Build/Flash MCUboot"},{"location":"zephyr-project/zephyr-project-guide/#step-2-start-the-updatehub-server","text":"","title":"Step 2: Start the UpdateHub Server"},{"location":"zephyr-project/zephyr-project-guide/#step-21-updatehub-ce-community-edition","text":"The Zephyr sample application is configured by default to use the UpdateHub-CE server edition. This version implies you need run your own server. The UpdateHub-CE is distributed as a docker container and can be on your local network or even instaled on a service provider like Digital Ocean, Vultr etc. To start using the UpdateHub-CE simple execute the docker command with the following parameters on another terminal terminal 2 . docker run -it -p 8080:8080 -p 5683:5683/udp --rm updatehub/updatehub-ce:latest","title":"Step 2.1: UpdateHub-CE (Community Edition)"},{"location":"zephyr-project/zephyr-project-guide/#step-22-updatehub-cloud","text":"The UpdateHub Cloud is an enterprise-grade solution. It provides almost same resources than UpdateHub-CE with the DTLS as main diferential. For more details on how to use the UpdateHub Cloud please refer to the documentation on UpdateHub Cloud . The UpdateHub Cloud has the option to use CoAPS/DTLS or not. If you want to use the CoAPS/DTLS, simply add the overlay-dtls.conf when building the sample. You can use the provided certificate for test this example or create your own. The below procedure instruct how create a new certificate using openssl on a Linux machine on terminal terminal 2 . openssl genrsa -out privkey.pem 512 openssl req -new -x509 -key privkey.pem -out servercert.pem The servercert and privkey files must be embedded in the application by certificates.h file. The following procedure can be used to generated the required der files: openssl x509 -in servercert.pem -outform DER -out servercert.der openssl pkcs8 -topk8 -inform PEM -outform DER -nocrypt -in privkey.pem -out privkey.der The der files should be placed on the sample source at certificates directory. Note When using UpdateHub Cloud server it is necessary update your own overlay-prj.conf with option CONFIG_UPDATEHUB_CE equal n .","title":"Step 2.2: UpdateHub Cloud"},{"location":"zephyr-project/zephyr-project-guide/#step-3-configure-updatehub-sample","text":"The updatehub have several Kconfig options that are necessary configure to make it work or tune communication. Set CONFIG_UPDATEHUB_CE select between UpdateHub edition. The y value will select UpdateHub-CE otherwise n selects UpdateHub Cloud. Set CONFIG_UPDATEHUB_SERVER with your local IP address that runs the UpdateHub-CE server edition. If your are using a service provider a DNS name is a valid option too. This option is only valid when using UpdateHub-CE. Set CONFIG_UPDATEHUB_POLL_INTERVAL with the polling period of your preference, remembering that the limit is between 0 and 43200 minutes (30 days). The default value is 1440 minutes (24h). Set CONFIG_UPDATEHUB_PRODUCT_UID with your product ID. When using UpdateHub-CE the valid is available at overlay-prj.conf.example file.","title":"Step 3: Configure UpdateHub Sample"},{"location":"zephyr-project/zephyr-project-guide/#step-4-build-updatehub-app","text":"In order to correctly build UpdateHub the overlay files must be use correctly. More information about overlay files in :ref: important-build-vars . Note It is out of scope at this moment provide support for experimental features. However, the configuration and use is similar to the start point indicated on the experimental network interface.","title":"Step 4: Build UpdateHub App"},{"location":"zephyr-project/zephyr-project-guide/#step-41-build-for-ethernet","text":"The ethernet depends only from base configuration. west build -b [ frdm_k64f | nucleo_f767zi ] \\ -d build/app zephyr/samples/subsys/mgmt/updatehub -- \\ -DOVERLAY_CONFIG=overlay-prj.conf","title":"Step 4.1: Build for Ethernet"},{"location":"zephyr-project/zephyr-project-guide/#step-42-build-for-wifi","text":"For WiFi, it needs add overlay-wifi.conf . Here a shield provides WiFi connectivity using, for instance, arduino headers. See ESP-8266 Module for details. west build -b [ frdm_k64f | nrf52840dk_nrf52840 | nucleo_f767zi ] \\ -d build/app zephyr/samples/subsys/mgmt/updatehub -- \\ -DSHIELD=esp_8266_arduino \\ -DOVERLAY_CONFIG=\"overlay-wifi.conf;overlay-prj.conf\" Note The board disco_l475_iot1 is not supported. The es-WIFI driver currently doesn't support UDP.","title":"Step 4.2: Build for WiFi"},{"location":"zephyr-project/zephyr-project-guide/#step-43-build-for-modem","text":"Modem needs add overlay-modem.conf . Now, a DTC overlay file is used to configure the glue between the modem and an arduino headers. The modem config uses PPP over GSM modem, see Generic GSM Modem Sample . west build -b [ frdm_k64f | nrf52840dk_nrf52840 | nucleo_f767zi ] \\ -d build/app zephyr/samples/subsys/mgmt/updatehub -- \\ -DOVERLAY_CONFIG=\"overlay-modem.conf;overlay-prj.conf\" \\ -DDTC_OVERLAY_FILE=arduino.overlay","title":"Step 4.3: Build for Modem"},{"location":"zephyr-project/zephyr-project-guide/#step-44-build-for-ieee-802154-experimental","text":"For IEEE 802.15.4 needs add overlay-802154.conf . This requires two nodes: one will be the host and the second one will be the device under test. The validation needs a Linux kernel >= 4.9 with all 6loWPAN support. The start point is try reproduce the Zephyr wpanusb sample . It is out of scope at this moment provide support since it is experimental. The gateway was tested with both native linux driver and atusb and with wpanusb sample. west build -b nrf52840dk_nrf52840 \\ -d build/app zephyr/samples/subsys/mgmt/updatehub -- \\ -DOVERLAY_CONFIG=\"overlay-802154.conf;overlay-prj.conf\" west build -b [ frdm_k64f | nucleo_f767zi ] \\ -d build/app zephyr/samples/subsys/mgmt/updatehub -- \\ -DSHIELD=atmel_rf2xx_arduino \\ -DOVERLAY_CONFIG=\"overlay-802154.conf;overlay-prj.conf\"","title":"Step 4.4: Build for IEEE 802.15.4 [experimental]"},{"location":"zephyr-project/zephyr-project-guide/#step-45-build-for-ble-ipsp-experimental","text":"The BLE IPSP needs overlay-ipsp.conf . This may requires two nodes: one will be the host and the second one will be the device under test. The validation needs a Linux kernel >= 4.9 with all 6loWPAN support. In this particular case the Bluetooth 6LoWPAN module is needed. The start point is try reproduce the Zephyr Bluetooth: ipsp sample . It is out of scope at this moment provide support since it is experimental. The gateway was tested with native linux driver and an USB dongle. west build -b nrf52840dk_nrf52840 \\ -d build/app zephyr/samples/subsys/mgmt/updatehub -- \\ -DOVERLAY_CONFIG=\"overlay-ipsp.conf;overlay-prj.conf\"","title":"Step 4.5: Build for BLE IPSP [experimental]"},{"location":"zephyr-project/zephyr-project-guide/#step-46-build-for-openthread-network-experimental","text":"The OpenThread requries the overlay-ot.conf . It requires two nodes: one will be the host NCP and the second one will be the device under test. The validation needs a Linux kernel >= 4.9 with optional NAT-64 support. The start point is try reproduce the OpenThread Router . It is out of scope at this moment provide support since it is experimental. The gateway was tested using two boards with OpenThread 1.1.1 on NCP mode. west build -b nrf52840dk_nrf52840 \\ -d build/app zephyr/samples/subsys/mgmt/updatehub -- \\ -DOVERLAY_CONFIG=\"overlay-ot.conf;overlay-prj.conf\"","title":"Step 4.6: Build for OpenThread Network [experimental]"},{"location":"zephyr-project/zephyr-project-guide/#step-5-sign-the-app-image","text":"The app image is the application itself that will be on the board. This app will connect to UpdateHub server and check for new images. The image will be loaded on the board with version 1.0.0. It is important check what file format you SoC tools uses. In general, Zephyr can create images with binary ( .bin ) image format or Intel's ( .hex ) image format. The Zephyr provide the west tool that simplify the signing process. Just call west with proper parameter values: west sign -t imgtool -d build/app -- --version 1.0.0 --pad \\ --key bootloader/mcuboot/root-rsa-2048.pem === image configuration: partition offset: 131072 (0x20000) partition size: 393216 (0x60000) rom start offset: 512 (0x200) === signing binaries unsigned bin: <zephyrdir>/build/app/zephyr/zephyr.bin signed bin: <zephyrdir>/build/app/zephyr/zephyr.signed.bin","title":"Step 5: Sign the app image"},{"location":"zephyr-project/zephyr-project-guide/#step-6-flash-the-app-image","text":"west flash -d build/app --bin-file build/app/zephyr/zephyr.signed.bin Note: Command variation to flash a hex file west flash -d build/app --hex-file build/app/zephyr/zephyr.signed.hex At this point you can access a third terminal terminal 3 to check if image is running. Open the terminal 3 and press reset on your board: minicom -D /dev/ttyACM0","title":"Step 6: Flash the app image"},{"location":"zephyr-project/zephyr-project-guide/#step-7-signing-the-binary-test-image","text":"The test image needs different parameters to add the signature. Pay attention to make sure you are creating the right signed image. The test image will be created with version 2.0.0 in this tutorial: west sign --no-hex --bin -B build/zephyr-2.0.0.bin -t imgtool -d build/app -- \\ --version 2.0.0 --key bootloader/mcuboot/root-rsa-2048.pem === image configuration: partition offset: 131072 (0x20000) partition size: 393216 (0x60000) rom start offset: 512 (0x200) === signing binaries unsigned bin: <zephyrdir>/build/app/zephyr/zephyr.bin signed bin: build/zephyr-2.0.0.bin","title":"Step 7: Signing the binary test image"},{"location":"zephyr-project/zephyr-project-guide/#step-8-create-a-package-with-updatehub-utilities-uhu","text":"First, install UpdateHub Utilities ( uhu ) on your system, using: pip3 install --user uhu After installing uhu you will need to set the product-uid . The value for UpdateHub-CE can be found at overlay-prj.conf.example file. For UpdateHub Cloud, you need copy the value from the web interface. uhu product use \"e4d37cfe6ec48a2d069cc0bbb8b078677e9a0d8df3a027c4d8ea131130c4265f\" Then, add the package and its mode ( zephyr ): uhu package add build/zephyr-2.0.0.bin -m zephyr Then inform what version this image is: uhu package version 2.0.0 And finally you can build the package by running: uhu package archive --output build/zephyr-2.0.0.pkg The remaining steps are dedicated to UpdateHub-CE. If you are using UpdateHub Cloud you can find the proper procedure at docs.updatehub.io _.","title":"Step 8: Create a package with UpdateHub Utilities (uhu)"},{"location":"zephyr-project/zephyr-project-guide/#step-9-add-the-package-to-server","text":"","title":"Step 9: Add the package to server"},{"location":"zephyr-project/zephyr-project-guide/#step-91-updatehub-ce","text":"Add the package to the UpdateHub-CE server. Open your browser to the server URL, <your-ip-address>:8080 , and logging into the server using admin as the login and password by default. After logging in, click on the package menu, then UPLOAD PACKAGE , and select the package built in step 8.","title":"Step 9.1: UpdateHub-CE"},{"location":"zephyr-project/zephyr-project-guide/#step-92-updatehub-cloud","text":"UpdateHub Cloud allows manager packages only by API. To enable API access by terminal, add following three environment variables: export UHU_ACCESS_ID=\"<email address>-<id number>\" export UHU_ACCESS_SECRET=\"<your secret>\" export UHU_SERVER_URL=\"https://api.updatehub.io\" The last step is call package push to send package built in step 8 to UpdateHub cloud server. uhu package push Note This can be easilly integrated with a CI/CD development workflow","title":"Step 9.2: UpdateHub Cloud"},{"location":"zephyr-project/zephyr-project-guide/#step-10-register-device-on-server","text":"If you chose Manual , register your device at updatehub server by using the terminal session where you are debugging the board terminal 3 . Type the following command: updatehub run If everything is alright, it will print on the screen No update available . For Polling mode, the system will automatically register your device after CONFIG_UPDATEHUB_POLL_INTERVAL minutes. The updatehub run can be used to speed-up. Note The message Could not receive data means that the application was not able to reached the updatehub server for some reason. The most common cases are server down, missing network routes and forget to change the content of overlay-prj.conf file.","title":"Step 10: Register device on server"},{"location":"zephyr-project/zephyr-project-guide/#step-11-create-a-rollout","text":"In the browser where the UpdateHub-CE is open, click on menu Rollout and then CREATE ROLLOUT . Select the version of the package that you added in step 9. With that, the update is published, and the server is ready to accept update requests.","title":"Step 11: Create a rollout"},{"location":"zephyr-project/zephyr-project-guide/#step-12-run-the-update","text":"Back in the terminal session that you used for debugging the board, type the following command: updatehub run And then wait. The board will probe the server, check if there are any new updates, and then download the update package you've just created. If everything goes fine the message Image flashed successfully, you can reboot now will be printed on the terminal. If you are using the Polling mode the board will reboot automatically and Step 13 can be skipped.","title":"Step 12: Run the update"},{"location":"zephyr-project/zephyr-project-guide/#step-13-reboot-the-system","text":"In the terminal you used for debugging the board, type the following command: kernel reboot cold Your board will reboot and then start with the new image. After rebooting, the board will automatically ping the server again and the message No update available will be printed on the terminal. You can check the newer version using the following command: uart:~$ updatehub info Unique device id: acbdef0123456789 Firmware Version: 2.0.0 Product uid: e4d37cfe6ec48a2d069cc0bbb8b078677e9a0d8df3a027c4d8ea131130c4265f UpdateHub Server: <server ip/dns> uart:~$","title":"Step 13: Reboot the system"},{"location":"zephyr-project/zephyr-project-guide/#hardware","text":"The below list of hardware have been used by UpdateHub team. ID Network Interface Shield / Device 1 Ethernet Native 2 WIFI ESP-8266 3 MODEM (PPP) SIMCOM 808 4 IEEE 802.15.4 (6loWPAN) Native, RF2xx 5 BLE IPSP (6loWPAN) Native 6 OpenThread Network Native Board Network Interface ID NXP FRDM-K64F 1, 2, 3, 4 nRF52840 DK 2, 3, 4, 5, 6 ST Nucleo F767ZI 1, 2, 3, 4","title":"Hardware"}]}